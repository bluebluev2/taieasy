<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°é›»é€ä»¶å°å¹«æ‰‹</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
        /* V23 Final: Professional Theme */
        :root {
            --bg-body: #ebedef;
            --bg-sidebar: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --color-brand: #2c3e50;
            --color-accent: #2980b9;
            --color-danger: #c0392b;
            --color-success: #27ae60;
            --color-neutral: #95a5a6;
            --border-light: #dfe6e9;
        }

        body { margin: 0; padding: 0; display: flex; height: 100vh; font-family: "Segoe UI", "Microsoft JhengHei", sans-serif; overflow: hidden; color: var(--text-primary); background: var(--bg-body); }
        
        .sidebar { 
            width: 360px; background: var(--bg-sidebar); padding: 20px; 
            display: flex; flex-direction: column; overflow-y: auto; z-index: 1000; 
            box-shadow: 4px 0 15px rgba(0,0,0,0.08); 
            transition: transform 0.3s ease; position: relative; flex-shrink: 0;
            border-right: 1px solid var(--border-light);
        }
        .sidebar.collapsed { transform: translateX(-360px); margin-right: -360px; }
        
        .sidebar h3 {
            margin-top: 0; padding-bottom: 15px; border-bottom: 2px solid var(--color-brand);
            color: var(--color-brand); font-weight: 800; font-size: 18px; letter-spacing: 0.5px;
            display: flex; align-items: center; gap: 8px;
        }

        .toggle-btn {
            position: absolute; top: 15px; right: -40px;
            width: 40px; height: 40px; background: var(--color-brand); color: white;
            border: none; border-radius: 0 4px 4px 0; cursor: pointer;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1); z-index: 2000;
        }

        .section { 
            margin-bottom: 18px; border: 1px solid var(--border-light); 
            padding: 15px; background: #fdfdfd; border-radius: 6px; 
            border-left: 4px solid var(--color-brand);
            box-shadow: 0 2px 6px rgba(0,0,0,0.03);
        }
        
        label { display: block; font-weight: 700; margin-bottom: 8px; font-size: 13px; color: var(--text-primary); }
        
        button { 
            width: 100%; padding: 9px; margin-top: 8px; cursor: pointer; 
            border: 1px solid transparent; border-radius: 4px; 
            color: white; font-weight: 600; font-size: 13px; transition: all 0.2s;
            background: var(--color-neutral);
        }
        button:hover { opacity: 0.9; transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        button:active { transform: translateY(0); }

        button.primary { background: var(--color-brand); }
        button.action  { background: var(--color-accent); }
        button.success { background: var(--color-success); }
        button.danger  { background: var(--color-danger); }
        button.outline { background: transparent; border: 1px solid var(--text-secondary); color: var(--text-secondary); }
        button.outline:hover { background: #f1f1f1; color: var(--text-primary); }

        .filter-controls { display: flex; gap: 5px; margin-top: 10px; align-items: center; }
        .filter-controls select { flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px; color: var(--text-primary); }
        .filter-controls button { margin-top: 0; width: auto; font-size: 12px; padding: 6px 10px; }

        #map { flex: 1; height: 100%; z-index: 0; cursor: crosshair; background: #e0e0e0; }
        
        .handle-icon { background: rgba(255, 255, 255, 0.9); border: 1px solid #333; border-radius: 50%; cursor: nwse-resize; box-shadow: 0 0 4px rgba(0,0,0,0.3); }
        .move-handle-icon { background: var(--color-brand); border: 2px solid white; border-radius: 4px; color: white; text-align: center; font-size: 16px; line-height: 18px; cursor: move; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .drag-point-icon { background: var(--color-accent); border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.4); cursor: move; }

        .status-msg { font-size: 12px; color: var(--text-secondary); margin-top: 6px; font-weight: 600; line-height: 1.4; padding: 4px 0; border-top: 1px dashed var(--border-light); }
        
        .scale-inputs { display: flex; gap: 10px; margin-top: 5px; }
        .scale-inputs div { flex: 1; }
        .scale-inputs input { width: 100%; padding: 6px; font-size: 12px; border: 1px solid #ccc; border-radius: 4px; background: #fff; }
        
        .draw-tools { display: flex; gap: 5px; flex-wrap: wrap; }
        .draw-tools button { flex: 1; min-width: 50px; font-size: 12px; background: #ecf0f1; color: var(--text-primary); border: 1px solid #bdc3c7; }
        .draw-tools button.active { background: var(--color-brand); color: white; border-color: var(--color-brand); }
        
        .tool-options { display: flex; align-items: center; gap: 10px; margin-top: 8px; font-size: 12px; background: #f8f9fa; padding: 8px; border-radius: 4px; border: 1px solid #eee; }
        
        #edit-panel {
            position: absolute; top: 80px; left: 420px; width: 280px;
            background: #ffffff; border: 1px solid #ccc; border-radius: 6px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            z-index: 2000; display: none; overflow: hidden;
        }
        .panel-header {
            background: var(--color-brand); color: white; padding: 12px 15px;
            font-size: 14px; font-weight: bold; cursor: move;
            display: flex; justify-content: space-between; align-items: center;
        }
        .panel-body { padding: 15px; background: #fff; }
        .panel-body input, .panel-body select { 
            width: 100%; margin-bottom: 12px; padding: 8px; box-sizing: border-box; 
            border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 13px;
        }
        .radius-control { display: flex; align-items: center; gap: 8px; margin-bottom: 15px; background: #f8f9fa; padding: 8px; border-radius: 4px; border: 1px solid #eee; }
        .radius-control input[type="range"] { flex: 1; margin: 0; cursor: pointer; }
        .radius-control input[type="number"] { width: 50px; margin: 0; text-align: center; border: 1px solid #ccc; }

        .panel-buttons { display: flex; gap: 10px; margin-top: 5px; padding-top: 10px; border-top: 1px solid #f1f1f1; }
        .close-panel-btn { background: transparent; border: none; color: rgba(255,255,255,0.7); cursor: pointer; font-size: 20px; padding: 0; line-height: 1; }
        .close-panel-btn:hover { color: white; }
    </style>
</head>
<body>

<div class="sidebar" id="sidebar">
    <button class="toggle-btn" onclick="toggleSidebar()">â˜°</button>
    <h3>âš¡ å°é›»é€ä»¶å°å¹«æ‰‹</h3>

    <div class="section">
        <label>1. åº•åœ–è¨­å®š(å°å¸³åœ–è³‡PDF)</label>
        <input type="file" id="pdf-input" accept="application/pdf" style="width:100%">
        <div id="auto-detect-msg" class="status-msg"></div>
        <div style="margin-top:10px; display:flex; gap:10px;">
            <div style="flex:1;">
                <label style="font-size:11px; margin:0; color:var(--text-secondary);">ç™½é‚Šä¿®æ­£ (å¯¬)</label>
                <input type="number" id="scale-x" value="1.24" step="0.01" onchange="recalcBounds()" style="width:100%; padding:5px; border:1px solid #ccc; border-radius:3px;">
            </div>
            <div style="flex:1;">
                <label style="font-size:11px; margin:0; color:var(--text-secondary);">ç™½é‚Šä¿®æ­£ (é«˜)</label>
                <input type="number" id="scale-y" value="1.42" step="0.01" onchange="recalcBounds()" style="width:100%; padding:5px; border:1px solid #ccc; border-radius:3px;">
            </div>
        </div>
        <label style="margin-top:12px; font-size:12px;">é€æ˜åº¦:</label>
        <input type="range" id="opacity-slider" min="0" max="1" step="0.1" value="0.6" style="width:100%; margin:0;">
        
        <div style="display:flex; align-items:center; margin-top:10px; font-size:12px;">
            <input type="checkbox" id="aspect-ratio-check" checked style="margin-right:5px;">
            <label for="aspect-ratio-check" style="margin:0; cursor:pointer; font-weight:normal;">é–å®šé•·å¯¬æ¯”</label>
        </div>
        
        <div style="display:flex; gap:5px; margin-top:5px;">
            <button id="btn-lock" class="outline" onclick="toggleLock()" disabled>ğŸ”’ é–å®šä½ç½®</button>
            <button class="outline" onclick="showBoundsInfo()">ğŸ“‹ é‚Šç•Œ</button>
        </div>
    </div>

    <div class="section">
        <label>2. åƒè€ƒ G-Code (ç¶ é»)</label>
        <div style="font-size:11px;color:var(--text-secondary);margin-bottom:8px;">* æ¬„ä½: G-code, G-x, G-y, G-W</div>
        <input type="file" id="ref-csv-input" accept=".csv" style="width:100%">
        <div style="margin-top:10px; display:flex; gap:5px; align-items:center;">
            <select id="csv-encoding" style="font-size:12px; padding:4px; border:1px solid #ccc; border-radius:3px;"><option value="UTF-8">UTF-8</option><option value="Big5">Big5</option></select>
            <div style="flex:1;"></div>
            <button onclick="clearRefMarkers()" style="width:auto; margin:0; padding:5px 10px; font-size:11px; background:var(--color-neutral);">æ¸…é™¤</button>
        </div>
        <div id="ref-status" style="font-size:12px; color:var(--color-success); margin-top:5px; font-weight:bold;"></div>
    </div>
    
    <div class="section">
        <label>3. è·¯ç‡ˆè³‡æ–™åŒ¯å…¥ (OUTPUT.csv)</label>
        <div style="font-size:11px;color:var(--text-secondary);margin-bottom:8px;">* æ¬„ä½: name, x, y, G-code_1st</div>
        <input type="file" id="sl-csv-input" accept=".csv" style="width:100%">
        
        <div style="margin-top:8px; display:flex; gap:5px; align-items:center;">
            <select id="sl-encoding" style="font-size:12px; padding:4px; border:1px solid #ccc; border-radius:3px;"><option value="UTF-8">UTF-8</option><option value="Big5">Big5</option></select>
            <div style="flex:1;"></div>
            <button onclick="clearStreetLights()" style="width:auto; margin:0; padding:5px 10px; font-size:11px; background:var(--color-neutral);">æ¸…é™¤</button>
        </div>
        
        <label style="margin-top:12px; margin-bottom:4px; font-size:12px;">ç¯©é¸èˆ‡æ“ä½œ:</label>
        <div class="filter-controls">
            <select id="sl-filter" onchange="updateFilter()">
                <option value="all">ğŸ‘ï¸ é¡¯ç¤ºå…¨éƒ¨</option>
                <option value="å™¨è®Š">ğŸ”§ å™¨è®Š</option>
                <option value="å®¹è®Š">ğŸ’¡ å®¹è®Š (LED)</option>
                <option value="å¢è¨­">â• å¢è¨­</option>
                <option value="å¾…ç¢ºèª">â“ å¾…ç¢ºèª (ç„¡G-code)</option>
            </select>
            <button class="success" onclick="addManualStreetLight()">â• æ‰‹å‹•æ–°å¢</button>
        </div>
        <div id="sl-status" style="font-size:12px; color:var(--color-accent); margin-top:5px; font-weight:bold;"></div>
        
        <button class="action" onclick="exportRegistrationSheet()" style="margin-top:10px;">ğŸ“Š åŒ¯å‡ºç¯©é¸å¾Œç™»è¨˜å–®</button>
    </div>

    <div class="section">
        <label>4. æ‰‹å‹•ç¹ªåœ– (Draw)</label>
        <div class="draw-tools">
            <button onclick="setDrawMode('circle')" id="btn-draw-circle">â­• åœ“</button>
            <button onclick="setDrawMode('line')" id="btn-draw-line">â– ç·š</button>
            <button onclick="setDrawMode('text')" id="btn-draw-text">Aa å­—</button>
            <button onclick="setDrawMode(null)" id="btn-draw-cancel" style="background:#e0e0e0; color:#555;">âœ‹ åœæ­¢</button>
        </div>
        <div class="tool-options">
            <div style="display:flex; align-items:center; gap:5px;">
                <span style="color:#666">é¡è‰²:</span>
                <input type="color" id="input-color" value="#e74c3c" style="width:25px; height:25px; border:none; cursor:pointer; padding:0;">
            </div>
            <div style="display:flex; align-items:center; gap:5px;">
                <span style="color:#666">å­—ç´š:</span>
                <input type="number" id="input-font-size" value="16" min="8" max="72" style="width:40px; padding:2px; text-align:center; border:1px solid #ccc;">
            </div>
        </div>
        <button onclick="clearDrawings()" class="danger" style="margin-top:10px;">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ‰‹ç¹ª</button>
    </div>

    <div class="section" style="border-left:none; background:transparent; padding:0; box-shadow:none;">
        <button class="primary" onclick="exportPDF()" style="font-size:15px; padding:12px; margin-bottom:10px;">ğŸ’¾ åŒ¯å‡ºåœ–å±¤ PDF (å«ç¯©é¸)</button>
        <div style="display:flex; gap:8px;">
            <button class="outline" onclick="saveProject()" style="background:#fff;">ğŸ“‚ å„²å­˜å°ˆæ¡ˆ</button>
            <button class="outline" onclick="loadProjectClick()" style="background:#fff;">ğŸ“‚ è¼‰å…¥å°ˆæ¡ˆ</button>
        </div>
        <input type="file" id="project-input" accept=".json" style="display: none;">
    </div>
</div>

<div id="map"></div>

<div id="edit-panel">
    <div class="panel-header" id="panel-header">
        <span>ğŸ› ï¸ å±¬æ€§ç·¨è¼¯</span>
        <button class="close-panel-btn" onclick="closeEditPanel()">Ã—</button>
    </div>
    <div class="panel-body">
        <div style="margin-bottom:10px; padding:5px; background:#f0f8ff; border:1px solid #b6d4fe; border-radius:4px; font-size:12px;">
            ç•¶å‰é¡åˆ¥: <b id="edit-type-display" style="color:var(--color-accent)">--</b>
        </div>

        <label>G-code (åº§æ¨™):</label>
        <input type="text" id="edit-gcode" placeholder="ç•™ç©ºè¦–ç‚ºå¢è¨­..." onchange="updateEditProcessType()">
        
        <label>è®Šæ›´å‰å®¹é‡:</label>
        <input list="list-old-cap" id="edit-old" placeholder="ä¾‹å¦‚: 73W">
        
        <label>è®Šæ›´å¾Œå®¹é‡(VA):</label>
        <input list="list-new-cap" id="edit-new" placeholder="ä¾‹å¦‚: 73VA">

        <label>ç´…åœˆåŠå¾‘ (å…¬å°º):</label>
        <div class="radius-control">
            <input type="range" id="edit-radius-slider" min="1" max="20" step="0.5" value="7">
            <input type="number" id="edit-radius-input" value="7" min="1" max="20" step="0.5">
        </div>

        <div class="panel-buttons">
            <button id="btn-panel-save" class="action">ç¢ºèªæ›´æ–°</button>
            <button id="btn-panel-reset" class="outline" style="color:var(--text-primary); border-color:#ccc;">æ¢å¾©ä½ç½®</button>
        </div>
    </div>
</div>

<canvas id="text-helper-canvas" style="display:none;"></canvas>

<datalist id="list-old-cap">
    <option value="73W">
    <option value="112W">
    <option value="220W">
    <option value="250W">
</datalist>
<datalist id="list-new-cap">
    <option value="73VA">
    <option value="88VA">
</datalist>

<script>
    // --- Init ---
    proj4.defs("EPSG:3828", "+proj=tmerc +lat_0=0 +lon_0=121 +x_0=250000 +y_0=0 +k=0.9999 +ellps=aust_SA +towgs84=-752,-358,-179,-.0000011698,.0000018398,.0000009822,.00002329 +units=m +no_defs");
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
    const taiGridMap = {'A': [170000, 2750000], 'B': [250000, 2750000], 'C': [330000, 2750000], 'D': [170000, 2700000], 'E': [250000, 2700000], 'F': [330000, 2700000], 'G': [170000, 2650000], 'H': [250000, 2650000], 'J': [90000, 2600000], 'K': [170000, 2600000], 'L': [250000, 2600000], 'M': [90000, 2550000], 'N': [170000, 2550000], 'O': [250000, 2550000], 'P': [90000, 2500000], 'Q': [170000, 2500000], 'R': [250000, 2500000], 'T': [170000, 2450000], 'U': [250000, 2450000], 'V': [170000, 2400000], 'W': [250000, 2400000], 'X': [275000, 2614000], 'Y': [275000, 2564000]};
    const EXACT_BOUNDS = { "G5050": [[24.183209, 120.613454], [24.176813, 120.623288]] };

    let map = L.map('map', { maxZoom: 25 }).setView([24.1800, 120.6200], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', maxZoom: 25, maxNativeZoom: 19 }).addTo(map);
    
    let pdfOverlay = null;
    let pdfDocBytes = null;
    let currentPdfName = "map"; 
    let boundsHandleNW, boundsHandleSE, boundsHandleCenter;
    let isLocked = false;
    let refMarkersLayer = L.layerGroup().addTo(map);
    let drawnItemsLayer = L.layerGroup().addTo(map);
    let streetLightsLayer = L.layerGroup().addTo(map);
    let streetLightsData = []; 
    // V23: Removed legacy markersData
    let refDataMap = {}; 
    let refMarkersData = []; 
    let currentBaseBounds = null;
    let currentDrawMode = null;
    let tempDrawShape = null;

    let currentEditingSL = null; 
    const editPanel = document.getElementById('edit-panel');
    const panelHeader = document.getElementById('panel-header');

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    function toggleSidebar() {
        document.getElementById('sidebar').classList.toggle('collapsed');
        setTimeout(() => { map.invalidateSize(); }, 300);
    }

    function getTimestampedName(baseName, ext) {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        const HH = String(now.getHours()).padStart(2, '0');
        const MM = String(now.getMinutes()).padStart(2, '0');
        const SS = String(now.getSeconds()).padStart(2, '0');
        return `${baseName}_${yyyy}${mm}${dd}_${HH}${MM}${SS}.${ext}`;
    }

    // --- PDF Logic ---
    document.getElementById('pdf-input').addEventListener('change', async function(e) {
        const file = e.target.files[0];
        if (!file) return;
        currentPdfName = file.name.replace(/\.[^/.]+$/, "");
        const rawBuffer = await file.arrayBuffer();
        pdfDocBytes = rawBuffer.slice(0);
        const displayBuffer = rawBuffer.slice(0);
        
        const gridInfo = getGridBounds(file.name);
        const msgDiv = document.getElementById('auto-detect-msg');
        let initialBounds;

        if (gridInfo) {
            if(gridInfo.type === 'exact') {
                msgDiv.innerHTML = `âœ… ${file.name.substring(0,5)} (ç²¾æº–)`;
                initialBounds = gridInfo.bounds;
                currentBaseBounds = null;
            } else {
                msgDiv.innerHTML = `âœ… ${file.name.substring(0,5)} (è‡ªå‹•ç™½é‚Š)`;
                currentBaseBounds = gridInfo.bounds;
                initialBounds = applyScale(gridInfo.bounds);
            }
        } else {
            msgDiv.innerText = `âš ï¸ æœªåµæ¸¬åˆ°åœ–è™Ÿ`;
            currentBaseBounds = null;
        }

        const loadingTask = pdfjsLib.getDocument(displayBuffer);
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 4 }); 
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        const imgUrl = canvas.toDataURL('image/png');

        if (!initialBounds) {
            const c = map.getCenter();
            const latRad = c.lat * Math.PI / 180;
            const hDeg = 0.005; 
            const wDeg = hDeg * (viewport.width / viewport.height) / Math.cos(latRad); 
            initialBounds = [[c.lat + hDeg/2, c.lng - wDeg/2], [c.lat - hDeg/2, c.lng + wDeg/2]];
        }

        if (pdfOverlay) map.removeLayer(pdfOverlay);
        clearControlHandles();
        pdfOverlay = L.imageOverlay(imgUrl, initialBounds, { opacity: 0.6 }).addTo(map);
        createControlHandles(initialBounds);
        document.getElementById('btn-lock').disabled = false;
        map.fitBounds(initialBounds);
    });

    function getGridBounds(filename) {
        const simpleName = filename.split('/').pop().split('.')[0].toUpperCase();
        if (EXACT_BOUNDS[simpleName]) return { type: 'exact', bounds: EXACT_BOUNDS[simpleName] };
        const match = simpleName.match(/([A-Z])(\d{2})(\d{2})/);
        if (!match) return null;
        const code = match[1], xIdx = parseInt(match[2]), yIdx = parseInt(match[3]);
        const base = taiGridMap[code];
        if (!base) return null;
        const startX = base[0] + (xIdx * 800), startY = base[1] + (yIdx * 500);
        const endX = startX + 800, endY = startY + 500;
        const p1 = proj4("EPSG:3828", "EPSG:4326", [startX, startY]);
        const p2 = proj4("EPSG:3828", "EPSG:4326", [endX, endY]);
        return { type: 'grid', bounds: [[p2[1], p1[0]], [p1[1], p2[0]]] };
    }

    function applyScale(gridBounds) {
        const scaleX = parseFloat(document.getElementById('scale-x').value) || 1.0;
        const scaleY = parseFloat(document.getElementById('scale-y').value) || 1.0;
        const N = gridBounds[0][0], W = gridBounds[0][1];
        const S = gridBounds[1][0], E = gridBounds[1][1];
        const cLat = (N + S) / 2, cLng = (W + E) / 2;
        const h = N - S, w = E - W;
        return [[cLat + (h*scaleY)/2, cLng - (w*scaleX)/2], [cLat - (h*scaleY)/2, cLng + (w*scaleX)/2]];
    }

    window.recalcBounds = function() {
        if (!currentBaseBounds || !pdfOverlay) return;
        const newBounds = applyScale(currentBaseBounds);
        pdfOverlay.setBounds(newBounds);
        clearControlHandles();
        createControlHandles(newBounds);
    };

    function clearControlHandles() {
        if (boundsHandleNW) map.removeLayer(boundsHandleNW);
        if (boundsHandleSE) map.removeLayer(boundsHandleSE);
        if (boundsHandleCenter) map.removeLayer(boundsHandleCenter);
    }
    function createControlHandles(bounds) {
        const icon = L.divIcon({ className: 'handle-icon', iconSize: [12, 12] });
        const centerIcon = L.divIcon({ className: 'move-handle-icon', html: '+', iconSize: [20, 20], iconAnchor: [10, 10] });
        boundsHandleNW = L.marker(bounds[0], { draggable: true, icon: icon }).addTo(map);
        boundsHandleSE = L.marker(bounds[1], { draggable: true, icon: icon }).addTo(map);
        const center = L.latLngBounds(bounds).getCenter();
        boundsHandleCenter = L.marker(center, { draggable: true, icon: centerIcon, zIndexOffset: 1000 }).addTo(map);

        const handleResize = (e) => {
            const isRatioLocked = document.getElementById('aspect-ratio-check').checked;
            const target = e.target;
            const isNW = (target === boundsHandleNW);
            let anchor = isNW ? boundsHandleSE.getLatLng() : boundsHandleNW.getLatLng();
            let current = target.getLatLng();
            if (isRatioLocked) {
                const oldB = pdfOverlay.getBounds();
                const oNW = oldB.getNorthWest(), oSE = oldB.getSouthEast();
                const ratio = (isNW ? (oNW.lng - oSE.lng) : (oSE.lng - oNW.lng)) / (isNW ? (oNW.lat - oSE.lat) : (oSE.lat - oNW.lat));
                current.lng = anchor.lng + (current.lat - anchor.lat) * ratio;
                target.setLatLng(current);
            }
            let newNW = isNW ? current : anchor, newSE = isNW ? anchor : current;
            pdfOverlay.setBounds([newNW, newSE]);
            boundsHandleCenter.setLatLng(L.latLngBounds([newNW, newSE]).getCenter());
        };
        const handleMove = (e) => {
            const newCenter = e.target.getLatLng();
            const oldCenter = pdfOverlay.getBounds().getCenter();
            const dLat = newCenter.lat - oldCenter.lat, dLng = newCenter.lng - oldCenter.lng;
            const b = pdfOverlay.getBounds();
            pdfOverlay.setBounds([[b.getNorth()+dLat, b.getWest()+dLng], [b.getSouth()+dLat, b.getEast()+dLng]]);
            boundsHandleNW.setLatLng([b.getNorth()+dLat, b.getWest()+dLng]);
            boundsHandleSE.setLatLng([b.getSouth()+dLat, b.getEast()+dLng]);
        };
        boundsHandleNW.on('drag', handleResize);
        boundsHandleSE.on('drag', handleResize);
        boundsHandleCenter.on('drag', handleMove);
    }
    function toggleLock() {
        if (!pdfOverlay) return;
        isLocked = !isLocked;
        const btn = document.getElementById('btn-lock');
        if (isLocked) {
            clearControlHandles();
            pdfOverlay.getElement().style.pointerEvents = 'none';
            btn.innerText = 'ğŸ”’ å·²é–å®š'; btn.className = 'success';
        } else {
            const b = pdfOverlay.getBounds();
            createControlHandles([b.getNorthWest(), b.getSouthEast()]);
            pdfOverlay.getElement().style.pointerEvents = 'auto';
            btn.innerText = 'ğŸ”“ é–å®š / è§£é–'; btn.className = 'warning';
        }
    }
    document.getElementById('opacity-slider').addEventListener('input', e => { if(pdfOverlay) pdfOverlay.setOpacity(e.target.value); });
    function showBoundsInfo() { if(pdfOverlay) alert(pdfOverlay.getBounds().toBBoxString()); }

    // --- Street Lights Logic ---
    document.getElementById('sl-csv-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const encoding = document.getElementById('sl-encoding').value;
        const inputElem = this;
        Papa.parse(file, {
            header: true, encoding: encoding, skipEmptyLines: true,
            complete: function(results) {
                let count = 0;
                results.data.forEach(row => {
                    const lat = parseFloat(row['y']), lng = parseFloat(row['x']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        createStreetLight({
                            name: row['name'],
                            g_code: row['G-code_1st'],
                            lat: lat,
                            lng: lng,
                            origLat: lat,
                            origLng: lng,
                            old_cap: "",
                            new_cap: "",
                            radius: 7 
                        });
                        count++;
                    }
                });
                document.getElementById('sl-status').innerText = `âœ… å·²è¼‰å…¥ ${count} ç­†è·¯ç‡ˆ`;
                inputElem.value = ''; 
                updateFilter();
            }
        });
    });

    function getProcessType(g_code) {
        if (!g_code || g_code.trim() === "") return "å¢è¨­";
        const gw = refDataMap[g_code];
        if (!gw) return "å¾…ç¢ºèª"; 
        if (gw.includes("éˆ‰å…‰ç‡ˆ")) return "å™¨è®Š";
        if (gw.includes("LED")) return "å®¹è®Š";
        return "å¾…ç¢ºèª"; 
    }

    function createStreetLight(data) {
        if(!data.radius) data.radius = 7;
        
        if(!data.processType) {
            data.processType = getProcessType(data.g_code);
        }

        const marker = L.marker([data.lat, data.lng], {
            icon: L.divIcon({className:'drag-point-icon', iconSize:[12,12], bgPos:[0,0]}), 
            draggable: true
        }).addTo(streetLightsLayer);

        marker.bindTooltip(`<b>${data.name}</b><br>${data.g_code}<br><small>[${data.processType}]</small>`, { offset: [0, -5], direction: 'top' });

        const circle = L.circle([data.lat, data.lng], {radius: data.radius, color:'red', weight:2}).addTo(streetLightsLayer);

        const textLabel = L.marker([data.lat, data.lng], {
            icon: L.divIcon({ 
                className: 'text-label', 
                html: generateLabelHtml(data.name, data.new_cap), 
                iconSize: [150, 20], 
                iconAnchor: [-45, 10] 
            }),
            interactive: true, draggable: false 
        }).addTo(streetLightsLayer);

        const slObj = {
            id: Date.now() + Math.random(),
            data: data,
            layers: { marker, circle, textLabel }
        };
        streetLightsData.push(slObj);

        marker.on('drag', e => {
            circle.setLatLng(e.latlng);
            textLabel.setLatLng(e.latlng);
            slObj.data.lat = e.latlng.lat;
            slObj.data.lng = e.latlng.lng;
        });

        marker.on('click', (e) => {
            L.DomEvent.stopPropagation(e);
            openEditPanel(slObj);
        });
    }

    // V23: Manual Add with Name Prompt
    window.addManualStreetLight = function() {
        const name = prompt("è«‹è¼¸å…¥è·¯ç‡ˆåç¨±/ç·¨è™Ÿ:", "æ–°è·¯ç‡ˆ");
        if(name === null) return; 

        const center = map.getCenter();
        createStreetLight({
            name: name || "æ–°è·¯ç‡ˆ",
            g_code: "", 
            lat: center.lat,
            lng: center.lng,
            origLat: center.lat,
            origLng: center.lng,
            old_cap: "",
            new_cap: "",
            radius: 7
        });
        updateFilter(); 
    };

    window.updateFilter = function() {
        const filterVal = document.getElementById('sl-filter').value;
        streetLightsData.forEach(sl => {
            const isVisible = (filterVal === 'all') || (sl.data.processType === filterVal);
            if(isVisible) {
                if(!map.hasLayer(sl.layers.marker)) {
                    streetLightsLayer.addLayer(sl.layers.marker);
                    streetLightsLayer.addLayer(sl.layers.circle);
                    streetLightsLayer.addLayer(sl.layers.textLabel);
                }
            } else {
                streetLightsLayer.removeLayer(sl.layers.marker);
                streetLightsLayer.removeLayer(sl.layers.circle);
                streetLightsLayer.removeLayer(sl.layers.textLabel);
            }
        });
        const visibleCount = streetLightsData.filter(sl => (filterVal === 'all') || (sl.data.processType === filterVal)).length;
        document.getElementById('sl-status').innerText = `âœ… ç›®å‰é¡¯ç¤º: ${visibleCount} ç­† (${filterVal === 'all' ? 'å…¨éƒ¨' : filterVal})`;
    };

    function generateLabelHtml(name, cap) {
        const text = name + (cap ? `(${cap})` : "");
        return `<div style="color:red;font-size:14px;font-weight:bold;text-shadow:1px 1px 0 #fff;white-space:nowrap;">${text}</div>`;
    }

    function openEditPanel(slObj) {
        closeEditPanel();
        currentEditingSL = slObj;
        
        document.getElementById('edit-gcode').value = slObj.data.g_code || "";
        document.getElementById('edit-old').value = slObj.data.old_cap || "";
        document.getElementById('edit-new').value = slObj.data.new_cap || "";
        document.getElementById('edit-type-display').innerText = slObj.data.processType || "æœªçŸ¥";
        
        const r = slObj.data.radius || 7;
        document.getElementById('edit-radius-slider').value = r;
        document.getElementById('edit-radius-input').value = r;

        slObj.layers.textLabel.dragging.enable();
        slObj.layers.textLabel.getElement().style.cursor = 'move';
        slObj.layers.textLabel.getElement().style.border = '1px dashed red'; 

        editPanel.style.display = 'block';
    }

    window.closeEditPanel = function() {
        if (currentEditingSL) {
            currentEditingSL.layers.textLabel.dragging.disable();
            if(currentEditingSL.layers.textLabel.getElement()) {
                currentEditingSL.layers.textLabel.getElement().style.cursor = '';
                currentEditingSL.layers.textLabel.getElement().style.border = 'none';
            }
            currentEditingSL = null;
        }
        editPanel.style.display = 'none';
    };

    window.updateEditProcessType = function() {
        if(!currentEditingSL) return;
        const newCode = document.getElementById('edit-gcode').value;
        const newType = getProcessType(newCode);
        document.getElementById('edit-type-display').innerText = newType;
    }

    const rSlider = document.getElementById('edit-radius-slider');
    const rInput = document.getElementById('edit-radius-input');
    
    function updateRadius(val) {
        val = parseFloat(val);
        rSlider.value = val;
        rInput.value = val;
        if(currentEditingSL) {
            currentEditingSL.data.radius = val;
            currentEditingSL.layers.circle.setRadius(val);
        }
    }
    rSlider.oninput = function() { updateRadius(this.value); };
    rInput.onchange = function() { updateRadius(this.value); };

    document.getElementById('btn-panel-save').onclick = function() {
        if (!currentEditingSL) return;
        const slObj = currentEditingSL;
        
        slObj.data.g_code = document.getElementById('edit-gcode').value;
        slObj.data.old_cap = document.getElementById('edit-old').value;
        slObj.data.new_cap = document.getElementById('edit-new').value;
        
        slObj.data.processType = getProcessType(slObj.data.g_code);

        const newHtml = generateLabelHtml(slObj.data.name, slObj.data.new_cap);
        slObj.layers.textLabel.setIcon(L.divIcon({ 
            className: 'text-label', html: newHtml, iconSize: [150, 20], 
            iconAnchor: [-45, 10] 
        }));
        
        slObj.layers.marker.setTooltipContent(`<b>${slObj.data.name}</b><br>${slObj.data.g_code}<br><small>[${slObj.data.processType}]</small>`);
        
        closeEditPanel();
        updateFilter(); 
    };

    document.getElementById('btn-panel-reset').onclick = function() {
        if (!currentEditingSL) return;
        const slObj = currentEditingSL;
        const orig = L.latLng(slObj.data.origLat, slObj.data.origLng);
        
        slObj.layers.marker.setLatLng(orig);
        slObj.layers.circle.setLatLng(orig);
        slObj.layers.textLabel.setLatLng(orig);
        slObj.data.lat = orig.lat; slObj.data.lng = orig.lng;
        
        closeEditPanel();
    };

    let isPanelDragging = false;
    let panelOffsetX, panelOffsetY;
    panelHeader.addEventListener('mousedown', (e) => {
        isPanelDragging = true;
        panelOffsetX = e.clientX - editPanel.offsetLeft;
        panelOffsetY = e.clientY - editPanel.offsetTop;
        document.body.style.userSelect = 'none'; 
    });
    document.addEventListener('mousemove', (e) => {
        if (isPanelDragging) {
            editPanel.style.left = (e.clientX - panelOffsetX) + 'px';
            editPanel.style.top = (e.clientY - panelOffsetY) + 'px';
        }
    });
    document.addEventListener('mouseup', () => { isPanelDragging = false; document.body.style.userSelect = ''; });

    window.clearStreetLights = function(force = false) {
        if(force || confirm("æ¸…é™¤æ‰€æœ‰è·¯ç‡ˆè³‡æ–™?")) {
            streetLightsLayer.clearLayers();
            streetLightsData = [];
            document.getElementById('sl-status').innerText = "";
            document.getElementById('sl-csv-input').value = ""; 
            closeEditPanel();
        }
    };

    window.exportRegistrationSheet = function() {
        const filterVal = document.getElementById('sl-filter').value;
        const exportData = streetLightsData.filter(sl => (filterVal === 'all') || (sl.data.processType === filterVal));

        if(exportData.length === 0) return alert(`ç›®å‰ç¯©é¸ (${filterVal}) ç„¡è³‡æ–™å¯åŒ¯å‡º`);
        
        const csvRows = [];
        csvRows.push(["åºè™Ÿ","è®Šæ›´å‰é›»è™Ÿ","è®Šæ›´å¾Œé›»è™Ÿ","è¡Œæ”¿å€","è£è¨­ä½ç½®æˆ–åœ°å€","è£è¨­åœ°é»åº§æ¨™","è·¯ç‡ˆç·¨è™Ÿ(æ–°)","è®Šæ›´å‰ç‡ˆåˆ¥","è®Šæ›´å‰å°å¸³å®¹é‡","è®Šæ›´å‰å°å¸³ç›æ•¸","è®Šæ›´å¾Œç‡ˆåˆ¥","è®Šæ›´å¾Œå®¹é‡(VA)","è®Šæ›´å¾Œç›æ•¸","æœå‹™æ‰€","å—ç†è™Ÿç¢¼"]);
        
        exportData.forEach((item, index) => {
            const d = item.data;
            const matchedGW = refDataMap[d.g_code] || ""; 

            const row = [
                index + 1, 
                "", "", "", "", 
                d.g_code || "", 
                d.name || "",   
                matchedGW,          
                d.old_cap || "", 
                "1",            
                "LED",          
                d.new_cap || "", 
                "1",            
                "", ""      
            ];
            const safeRow = row.map(field => {
                const s = String(field);
                if (s.includes(",") || s.includes('"') || s.includes("\n")) {
                    return `"${s.replace(/"/g, '""')}"`;
                }
                return s;
            });
            csvRows.push(safeRow.join(","));
        });

        const csvContent = "\uFEFF" + csvRows.join("\n"); 
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const typeName = (filterVal === 'all') ? 'å…¨æ¡ˆ' : filterVal;
        const fname = getTimestampedName(`${currentPdfName}_${typeName}ç™»è¨˜å–®`, "csv");
        link.href = URL.createObjectURL(blob);
        link.download = fname;
        link.click();
    };

    window.setDrawMode = function(mode) {
        currentDrawMode = mode;
        map.dragging.enable();
        document.querySelectorAll('.draw-tools button').forEach(b => b.classList.remove('active'));
        if(mode) {
            document.getElementById('btn-draw-'+mode).classList.add('active');
            map.dragging.disable(); map.getContainer().style.cursor = 'crosshair';
        } else { map.getContainer().style.cursor = ''; }
    };
    window.clearDrawings = function() { if(confirm("ç¢ºå®šæ¸…é™¤?")) drawnItemsLayer.clearLayers(); };

    function createEditableCircle(latlng, radius, color) {
        const group = L.layerGroup().addTo(drawnItemsLayer);
        group.drawType = 'circle'; group.color = color;
        const circle = L.circle(latlng, {radius: radius, color: color, weight:2}).addTo(group);
        const handle = L.marker(latlng, {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        handle.on('drag', evt => { circle.setLatLng(evt.latlng); });
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn">åˆªé™¤æ­¤åœ“</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(group); };
        handle.bindPopup(popupContent);
        return { group, circle, handle };
    }
    function createEditableLine(latlngs, color) {
        const group = L.layerGroup().addTo(drawnItemsLayer);
        group.drawType = 'line'; group.color = color;
        const line = L.polyline(latlngs, {color: color, weight:3}).addTo(group);
        const h1 = L.marker(latlngs[0], {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        const h2 = L.marker(latlngs[1], {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        const updateLine = () => { line.setLatLngs([h1.getLatLng(), h2.getLatLng()]); };
        h1.on('drag', updateLine); h2.on('drag', updateLine);
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn">åˆªé™¤æ­¤ç·š</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(group); };
        line.bindPopup(popupContent);
        return { group, line };
    }
    function createEditableText(latlng, text, fontSize, color) {
        const marker = L.marker(latlng, {
            icon: L.divIcon({ className: 'text-label', html: `<div style="color:${color};font-size:${fontSize}px;font-weight:bold;text-shadow:1px 1px 0 #fff;white-space:nowrap;line-height:20px;">${text}</div>`, iconSize: [100, 20], iconAnchor: [0, 10] }),
            interactive: true, draggable: true
        }).addTo(drawnItemsLayer);
        marker.drawType = 'text'; marker.textContent = text; marker.fontSize = fontSize; marker.color = color;
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn">åˆªé™¤æ–‡å­—</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(marker); };
        marker.bindPopup(popupContent);
        return marker;
    }

    let startPoint = null;
    map.on('mousedown', function(e) {
        if(!currentDrawMode) return;
        startPoint = e.latlng;
        const color = document.getElementById('input-color').value;
        if(currentDrawMode === 'circle') tempDrawShape = L.circle(startPoint, {radius: 1, color:color, weight:2}).addTo(map);
        else if(currentDrawMode === 'line') tempDrawShape = L.polyline([startPoint, startPoint], {color:color, weight:3}).addTo(map);
        else if(currentDrawMode === 'text') {
            const text = prompt("è¼¸å…¥æ–‡å­—:", "è¨»è¨˜");
            if(text) { const fs = document.getElementById('input-font-size').value || 16; createEditableText(startPoint, text, fs, color); }
            setDrawMode(null);
        }
    });
    map.on('mousemove', function(e) {
        if(!currentDrawMode || !startPoint || !tempDrawShape) return;
        if(currentDrawMode === 'circle') tempDrawShape.setRadius(map.distance(startPoint, e.latlng));
        else if(currentDrawMode === 'line') tempDrawShape.setLatLngs([startPoint, e.latlng]);
    });
    map.on('mouseup', function(e) {
        if(!currentDrawMode || !startPoint) return;
        const color = document.getElementById('input-color').value;
        if(tempDrawShape) {
            if(currentDrawMode === 'circle') { const r = tempDrawShape.getRadius(); map.removeLayer(tempDrawShape); createEditableCircle(startPoint, r, color); }
            else if (currentDrawMode === 'line') { const lls = tempDrawShape.getLatLngs(); map.removeLayer(tempDrawShape); createEditableLine(lls, color); }
        }
        startPoint = null; tempDrawShape = null; setDrawMode(null);
    });

    document.getElementById('ref-csv-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const encoding = document.getElementById('csv-encoding').value;
        const inputElem = this;
        Papa.parse(file, {
            header: true, encoding: encoding, skipEmptyLines: true,
            complete: function(results) {
                let count = 0;
                refDataMap = {}; 
                refMarkersData = []; 
                results.data.forEach(row => {
                    const lat = parseFloat(row['G-y']), lng = parseFloat(row['G-x']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        if(row['G-code']) {
                            refDataMap[row['G-code']] = row['G-W'] || "";
                        }
                        const refItem = { lat, lng, code: row['G-code'], w: row['G-W'] };
                        refMarkersData.push(refItem);

                        const popupHtml = `
                            <div style="font-size:14px; display:flex; align-items:center; gap:8px;">
                                <b style="cursor:pointer; color:#2980b9; text-decoration:underline;" 
                                   title="é»æ“Šè¤‡è£½" 
                                   onclick="navigator.clipboard.writeText('${row['G-code']}').then(()=>alert('å·²è¤‡è£½: ${row['G-code']}'))">
                                   ${row['G-code']}
                                </b>
                                <span style="font-size:12px; color:#666;">(é»æ“Šè¤‡è£½)</span>
                            </div>
                            <div style="margin-top:4px;">${row['G-W']||''}</div>
                        `;
                        L.circleMarker([lat, lng], { color: 'green', fillColor: '#90EE90', fillOpacity: 0.8, radius: 5 })
                         .bindPopup(popupHtml).addTo(refMarkersLayer);
                        count++;
                    }
                });
                document.getElementById('ref-status').innerText = `âœ… å·²è¼‰å…¥ ${count} å€‹ (å«ç´¢å¼•)`;
                inputElem.value = ''; 
                
                streetLightsData.forEach(sl => {
                    if(!sl.data.processType || sl.data.processType === "å¾…ç¢ºèª") {
                        sl.data.processType = getProcessType(sl.data.g_code);
                        sl.layers.marker.setTooltipContent(`<b>${sl.data.name}</b><br>${sl.data.g_code}<br><small>[${sl.data.processType}]</small>`);
                    }
                });
                updateFilter();
            }
        });
    });
    function clearRefMarkers() { refMarkersLayer.clearLayers(); refDataMap = {}; refMarkersData = []; }
    
    async function exportPDF() {
        if (!pdfDocBytes || !pdfOverlay) return alert("è«‹å…ˆä¸Šå‚³ PDF");
        try {
            const { PDFDocument, rgb } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfDocBytes);
            const page = pdfDoc.getPages()[0];
            const { width: pdfW, height: pdfH } = page.getSize();
            const b = pdfOverlay.getBounds();
            const north = b.getNorth(), south = b.getSouth(), east = b.getEast(), west = b.getWest();

            function toPdfPoint(lat, lng) {
                return { x: ((lng - west)/(east - west))*pdfW, y: ((lat - south)/(north - south))*pdfH };
            }
            const hexToRgb = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                return rgb(r, g, b);
            }
            async function textToImageBytes(text, fontSize, color) {
                const c = document.getElementById('text-helper-canvas');
                const ctx = c.getContext('2d');
                const scale = 3; const fontStr = `bold ${fontSize * scale}px "Microsoft JhengHei", sans-serif`; 
                ctx.font = fontStr;
                const metrics = ctx.measureText(text);
                const w = Math.ceil(metrics.width); const h = Math.ceil(fontSize * scale * 1.5); 
                c.width = w; c.height = h;
                ctx.font = fontStr; ctx.fillStyle = color; ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, h/2);
                return new Promise(resolve => { c.toBlob(blob => { blob.arrayBuffer().then(resolve); }, 'image/png'); });
            }

            const currentFilter = document.getElementById('sl-filter').value;

            for (const sl of streetLightsData) {
                if(currentFilter !== 'all' && sl.data.processType !== currentFilter) continue;

                const lat = sl.layers.circle.getLatLng().lat;
                const lng = sl.layers.circle.getLatLng().lng;
                const pt = toPdfPoint(lat, lng);
                
                const r = sl.data.radius || 7;
                const edgePt = toPdfPoint(lat + r/111111, lng); 
                const pdfR = Math.abs(edgePt.y - pt.y);
                page.drawCircle({ x: pt.x, y: pt.y, size: pdfR, borderColor: rgb(1,0,0), borderWidth: 2 });

                const textLat = sl.layers.textLabel.getLatLng().lat;
                const textLng = sl.layers.textLabel.getLatLng().lng;
                const txtPt = toPdfPoint(textLat, textLng);
                
                const labelText = sl.data.name + (sl.data.new_cap ? `(${sl.data.new_cap})` : "");
                
                if(labelText.trim()) {
                    const pngBytes = await textToImageBytes(labelText, 14, '#ff0000');
                    const pngImage = await pdfDoc.embedPng(pngBytes);
                    const dims = pngImage.scale(0.25);
                    page.drawImage(pngImage, { 
                        x: txtPt.x + 18, 
                        y: txtPt.y - (dims.height/2), 
                        width: dims.width, 
                        height: dims.height 
                    });
                }
            }

            drawnItemsLayer.eachLayer(layer => {
                if (layer.drawType === 'circle') {
                    let circleLayer; layer.eachLayer(l => { if(l instanceof L.Circle) circleLayer = l; });
                    if(circleLayer) {
                        const pt = toPdfPoint(circleLayer.getLatLng().lat, circleLayer.getLatLng().lng);
                        const pdfR = Math.abs(toPdfPoint(circleLayer.getLatLng().lat + circleLayer.getRadius()/111111, circleLayer.getLatLng().lng).y - pt.y);
                        page.drawCircle({ x: pt.x, y: pt.y, size: pdfR, borderColor: hexToRgb(layer.color||'#ff0000'), borderWidth: 2 });
                    }
                } else if (layer.drawType === 'line') {
                    let lineLayer; layer.eachLayer(l => { if(l instanceof L.Polyline) lineLayer = l; });
                    if(lineLayer) {
                        const lls = lineLayer.getLatLngs();
                        const p1 = toPdfPoint(lls[0].lat, lls[0].lng), p2 = toPdfPoint(lls[1].lat, lls[1].lng);
                        page.drawLine({ start: { x: p1.x, y: p1.y }, end: { x: p2.x, y: p2.y }, thickness: 2, color: hexToRgb(layer.color||'#ff0000') });
                    }
                } else if (layer.drawType === 'text') {
                    const pt = toPdfPoint(layer.getLatLng().lat, layer.getLatLng().lng);
                    const fs = parseInt(layer.fontSize || 16);
                    if(layer.textContent) {
                        (async () => {
                            const pngBytes = await textToImageBytes(layer.textContent, fs, layer.color||'#ff0000');
                            const pngImage = await pdfDoc.embedPng(pngBytes);
                            const dims = pngImage.scale(0.25);
                            page.drawImage(pngImage, { x: pt.x, y: pt.y - (dims.height/2), width: dims.width, height: dims.height });
                        })();
                    }
                }
            });
            
            await new Promise(r => setTimeout(r, 800)); 

            const outBytes = await pdfDoc.save();
            const blob = new Blob([outBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            const fname = getTimestampedName(currentPdfName, "pdf");
            link.href = URL.createObjectURL(blob);
            link.download = fname;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        } catch (err) { console.error(err); alert("åŒ¯å‡ºéŒ¯èª¤ï¼š" + err.message); }
    }

    function saveProject() {
        if(!pdfOverlay) return;
        const b = pdfOverlay.getBounds();
        const drawings = [];
        drawnItemsLayer.eachLayer(layer => {
            if(layer.drawType === 'circle') {
                let c; layer.eachLayer(l => { if(l instanceof L.Circle) c = l; });
                if(c) drawings.push({ type: 'circle', lat: c.getLatLng().lat, lng: c.getLatLng().lng, radius: c.getRadius(), color: layer.color });
            } else if(layer.drawType === 'line') {
                let l; layer.eachLayer(line => { if(line instanceof L.Polyline) l = line; });
                if(l) drawings.push({ type: 'line', latlngs: l.getLatLngs(), color: layer.color });
            } else if(layer.drawType === 'text') {
                drawings.push({ type: 'text', lat: layer.getLatLng().lat, lng: layer.getLatLng().lng, content: layer.textContent, fontSize: layer.fontSize, color: layer.color });
            }
        });
        
        const sls = streetLightsData.map(sl => {
            return {
                data: sl.data, 
                lat: sl.layers.marker.getLatLng().lat,
                lng: sl.layers.marker.getLatLng().lng,
                textLat: sl.layers.textLabel.getLatLng().lat,
                textLng: sl.layers.textLabel.getLatLng().lng
            };
        });

        const data = {
            bounds: { north: b.getNorth(), south: b.getSouth(), east: b.getEast(), west: b.getWest() },
            // V23 Final: Remove legacy markers save
            drawings: drawings,
            streetLights: sls,
            refMarkers: refMarkersData
        };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const link = document.createElement('a');
        const fname = getTimestampedName(currentPdfName, "json");
        link.href = URL.createObjectURL(blob);
        link.download = fname;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }

    function loadProjectClick() { document.getElementById('project-input').click(); }
    document.getElementById('project-input').addEventListener('change', e => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
            try {
                const d = JSON.parse(evt.target.result);
                
                // Clear existing
                clearStreetLights(true); 
                clearRefMarkers(); 
                clearDrawings(true); 
                drawnItemsLayer.clearLayers(); 

                // Restore Bounds
                if(d.bounds && pdfOverlay) {
                    const b = [[d.bounds.north, d.bounds.west], [d.bounds.south, d.bounds.east]];
                    pdfOverlay.setBounds(b);
                    map.fitBounds(b);
                    if(!isLocked) { clearControlHandles(); createControlHandles(pdfOverlay.getBounds()); }
                }
                
                // Restore Ref Markers (Safe Check)
                if(d.refMarkers && Array.isArray(d.refMarkers)) {
                    refMarkersData = d.refMarkers;
                    let count = 0;
                    d.refMarkers.forEach(row => {
                        const lat = row.lat, lng = row.lng;
                        if(row.code) refDataMap[row.code] = row.w || "";
                        
                        const popupHtml = `
                            <div style="font-size:14px; display:flex; align-items:center; gap:8px;">
                                <b style="cursor:pointer; color:#2980b9; text-decoration:underline;" 
                                   title="é»æ“Šè¤‡è£½" 
                                   onclick="navigator.clipboard.writeText('${row.code}').then(()=>alert('å·²è¤‡è£½: ${row.code}'))">
                                   ${row.code}
                                </b>
                                <span style="font-size:12px; color:#666;">(é»æ“Šè¤‡è£½)</span>
                            </div>
                            <div style="margin-top:4px;">${row.w||''}</div>
                        `;
                        L.circleMarker([lat, lng], { color: 'green', fillColor: '#90EE90', fillOpacity: 0.8, radius: 5 })
                         .bindPopup(popupHtml).addTo(refMarkersLayer);
                        count++;
                    });
                    document.getElementById('ref-status').innerText = `âœ… å·²é‚„åŸ ${count} å€‹ (å«ç´¢å¼•)`;
                } else {
                    refMarkersData = []; 
                }

                // V23 Final: Remove Legacy Markers Load Block completely

                // Restore Drawings
                if(d.drawings && Array.isArray(d.drawings)) {
                    d.drawings.forEach(item => {
                        const color = item.color || '#ff0000';
                        if(item.type === 'circle') createEditableCircle([item.lat, item.lng], item.radius, color);
                        else if(item.type === 'line') createEditableLine(item.latlngs, color);
                        else if(item.type === 'text') createEditableText([item.lat, item.lng], item.content, item.fontSize, color);
                    });
                }

                // Restore Street Lights
                if(d.streetLights && Array.isArray(d.streetLights)) {
                    d.streetLights.forEach(item => {
                        createStreetLight(item.data); 
                        
                        const sl = streetLightsData[streetLightsData.length-1];
                        // Safety check: skip if creation failed
                        if(!sl) return;

                        const newPt = L.latLng(item.lat, item.lng);
                        sl.layers.marker.setLatLng(newPt);
                        sl.layers.circle.setLatLng(newPt);
                        sl.layers.textLabel.setLatLng([item.textLat, item.textLng]);
                        const newHtml = generateLabelHtml(item.data.name, item.data.new_cap);
                        sl.layers.textLabel.setIcon(L.divIcon({ 
                            className: 'text-label', html: newHtml, iconSize: [150, 20], 
                            iconAnchor: [-45, 10] 
                        }));
                    });
                    document.getElementById('sl-status').innerText = `âœ… å·²é‚„åŸ ${d.streetLights.length} ç­†è·¯ç‡ˆ`;
                    try { updateFilter(); } catch(e) { console.warn("Filter update failed temporarily", e); }
                }
            } catch(err) { 
                console.error(err); 
                alert("è®€å–å¤±æ•—ï¼š\n" + err.message); 
            }
        };
        reader.readAsText(file);
    });
    
    function clearDrawings(silent=false) { if(silent || confirm("ç¢ºå®šæ¸…é™¤?")) drawnItemsLayer.clearLayers(); }

</script>
</body>
</html>
