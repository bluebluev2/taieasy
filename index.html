<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°é›»é€ä»¶å°å¹«æ‰‹ (V31 ç©©å®šç‰ˆ)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
        /* V31 Theme: Dark Power Engineering (Fixed Layout) */
        :root {
            /* User Defined Palette */
            --bg-sidebar: #333333;
            --bg-card: #001219;
            --text-main: #eceff1;
            --text-sub: #b0bec5;
            --accent-orange: #ffb703;
            --btn-primary: #ffb703;
            --btn-hover: #ffb703;
            --input-bg: #ffffff;
            --input-text: #455a64;
            --danger: #ef5350;
            --success: #ffb74d;
            --radius: 4px;
            
            /* Derived Colors */
            --border-color: #455a64;
        }

        body { 
            margin: 0; padding: 0; display: flex; height: 100vh; 
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            overflow: hidden; background: #e0e0e0;
        }
        
        /* Sidebar Layout - Structural Fix */
        .sidebar { 
            width: 300px; 
            background: var(--bg-sidebar); 
            color: var(--text-main);
            display: flex; flex-direction: column; 
            z-index: 1000; 
            box-shadow: 4px 0 15px rgba(0,0,0,0.5); 
            transition: transform 0.3s ease; 
            position: relative; 
            flex-shrink: 0;
            height: 100vh;
        }
        .sidebar.collapsed { transform: translateX(-300px); margin-right: -300px; }
        
        /* Scrollable Content Area */
        .sidebar-scroll-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            overflow-x: hidden;
        }
        .sidebar-scroll-area::-webkit-scrollbar { width: 8px; }
        .sidebar-scroll-area::-webkit-scrollbar-track { background: var(--bg-sidebar); }
        .sidebar-scroll-area::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        .sidebar-scroll-area::-webkit-scrollbar-thumb:hover { background: var(--accent-orange); }

        /* Header */
        .sidebar h3 {
            margin-top: 0; margin-bottom: 20px; padding-bottom: 15px;
            border-bottom: 2px solid var(--accent-orange);
            color: var(--accent-orange); 
            font-weight: 700; font-size: 18px; letter-spacing: 1px;
            display: flex; align-items: center; gap: 10px;
            text-transform: uppercase;
        }

        /* Toggle Button - Fixed */
        .toggle-btn {
            position: absolute; top: 15px; right: -40px;
            width: 40px; height: 40px; 
            background: var(--bg-sidebar); color: var(--accent-orange);
            border: none; border-radius: 0 4px 4px 0; cursor: pointer;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            box-shadow: 4px 2px 8px rgba(0,0,0,0.3); z-index: 2000;
        }
        .toggle-btn:hover { background: var(--bg-card); color: #fff; }

        /* Card / Section Styling */
        .section { 
            margin-bottom: 16px; 
            padding: 15px; 
            background: var(--bg-card); 
            border-radius: var(--radius);
            border: 1px solid rgba(255,255,255,0.05);
            border-left: 4px solid var(--accent-orange); 
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        label { display: block; font-weight: 500; margin-bottom: 8px; font-size: 13px; color: var(--text-main); }
        .sub-text { font-size: 11px; color: var(--text-sub); margin-bottom: 6px; display: block; }

        /* Inputs */
        input[type="text"], input[type="number"], select {
            width: 100%; padding: 8px; font-size: 13px; 
            border: 1px solid var(--border-color); border-radius: var(--radius); 
            background: var(--input-bg); color: var(--input-text);
            box-sizing: border-box;
        }
        input:focus, select:focus { outline: none; border-color: var(--accent-orange); box-shadow: 0 0 0 2px rgba(255, 183, 3, 0.4); }
        input[type="file"] { font-size: 12px; color: var(--text-sub); }

        /* Buttons */
        button { 
            width: 100%; padding: 9px 12px; margin-top: 10px; cursor: pointer; 
            border: none; border-radius: var(--radius); 
            font-weight: 700; font-size: 12px; letter-spacing: 0.5px;
            transition: all 0.2s; color: #000; 
            background: var(--btn-primary);
        }
        button:hover { background: var(--btn-hover); color: white; transform: translateY(-1px); }
        button:active { transform: translateY(0); }

        /* Button Variants */
        button.primary { background: var(--accent-orange); color: #263238; } 
        button.action  { background: var(--btn-primary); color: #001219; }
        button.success { background: var(--success); color: #001219; }
        
        button.danger  { background: transparent; border: 1px solid var(--danger); color: var(--danger); }
        button.danger:hover { background: var(--danger); color: white; }
        
        button.outline { 
            background: transparent; border: 1px solid var(--text-sub); color: var(--text-sub); font-weight: normal;
        }
        button.outline:hover { border-color: var(--text-main); color: var(--text-main); background: rgba(255,255,255,0.05); }

        /* Debug Button */
        .debug-footer {
            margin-top: 20px;
            padding-top: 20px;
            text-align: center;
            border-top: 1px dashed var(--border-color);
        }
        button.debug { 
            background: transparent; color: var(--text-sub); 
            font-size: 11px; text-decoration: underline; margin: 0; padding: 5px; width: auto; font-weight: normal;
        }
        button.debug:hover { color: var(--accent-orange); background: transparent; }

        /* Layout Helpers */
        .row { display: flex; gap: 8px; align-items: center; }
        .row > * { flex: 1; }
        
        .filter-controls { display: flex; gap: 6px; margin-top: 10px; }
        .filter-controls select { flex: 2; }
        .filter-controls button { flex: 1; margin-top: 0; padding: 8px; }

        .draw-tools { display: flex; gap: 5px; flex-wrap: wrap; }
        .draw-tools button { flex: 1; margin-top: 0; background: #263238; color: var(--text-main); border: 1px solid #455a64; color: #eceff1; }
        .draw-tools button.active { background: var(--accent-orange); color: #001219; border-color: var(--accent-orange); }
        
        .tool-options { 
            display: flex; align-items: center; gap: 10px; margin-top: 8px; 
            background: rgba(255,255,255,0.05); padding: 8px; border-radius: var(--radius); 
        }

        .status-msg { font-size: 11px; color: var(--success); margin-top: 6px; font-weight: bold; text-align: right; }

        /* Map */
        #map { flex: 1; height: 100%; z-index: 0; cursor: crosshair; background: #cfd8dc; }
        
        .handle-icon { background: rgba(255, 255, 255, 0.9); border: 1px solid #000; border-radius: 0; cursor: nwse-resize; }
        .move-handle-icon { background: var(--accent-orange); border: 2px solid #fff; border-radius: 4px; color: #000; text-align: center; font-size: 16px; line-height: 18px; cursor: move; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .drag-point-icon { background: var(--btn-hover); border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.4); cursor: move; }

        /* Edit Panel */
        #edit-panel {
            position: absolute; top: 80px; left: 340px; width: 280px;
            background: var(--bg-sidebar); border: 2px solid var(--accent-orange);
            box-shadow: 4px 4px 10px rgba(0,0,0,0.5);
            z-index: 2000; display: none; overflow: hidden;
            border-radius: var(--radius); color: var(--text-main);
        }
        .panel-header {
            background: var(--bg-card); color: var(--accent-orange); padding: 12px 15px;
            font-size: 14px; font-weight: bold; cursor: move;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #455a64;
        }
        .panel-body { padding: 15px; }
        .panel-body input { background: #fff; color: #000; } 
        
        .radius-control { display: flex; align-items: center; gap: 8px; margin-bottom: 15px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: var(--radius); }
        
        .panel-buttons { display: flex; gap: 10px; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        .close-panel-btn { background: transparent; border: none; color: var(--text-sub); cursor: pointer; font-size: 18px; width: auto; margin:0; padding:0; }
        .close-panel-btn:hover { color: white; }
    </style>
</head>
<body>

<div class="sidebar" id="sidebar">
    <button class="toggle-btn" onclick="toggleSidebar()">â˜°</button>
    
    <div class="sidebar-scroll-area">
        <h3>âš¡ å°é›»é€ä»¶å°å¹«æ‰‹</h3>

        <div class="section">
            <label>1. åº•åœ–è¨­å®š(å°å¸³åœ–è³‡PDF)</label>
            <input type="file" id="pdf-input" accept="application/pdf">
            <div id="auto-detect-msg" class="status-msg" style="color:var(--text-sub)"></div>
            
            <label style="margin-top:12px; font-size:12px;">é€æ˜åº¦:</label>
            <input type="range" id="opacity-slider" min="0" max="1" step="0.1" value="0.6" style="width:100%; margin:0;">
            
            <div style="display:flex; align-items:center; margin-top:10px; font-size:12px; color:var(--text-sub);">
                <input type="checkbox" id="aspect-ratio-check" checked style="width:auto; margin-right:5px;">
                <label for="aspect-ratio-check" style="margin:0; cursor:pointer; font-weight:normal; color:var(--text-main);">é–å®šé•·å¯¬æ¯”</label>
            </div>
            
            <div class="row">
                <button id="btn-lock" class="outline" onclick="toggleLock()" disabled>ğŸ”’ é–å®šä½ç½®</button>
                <button class="outline" onclick="showBoundsInfo()">ğŸ“‹ é‚Šç•Œ</button>
            </div>
        </div>

        <div class="section">
            <label>2. åƒè€ƒ G-Code (ç¶ é»)</label>
            <span class="sub-text">* æ¬„ä½: G-code, G-x, G-y, G-W</span>
            <input type="file" id="ref-csv-input" accept=".csv">
            <div class="filter-controls">
                <select id="csv-encoding">
                    <option value="UTF-8">UTF-8</option>
                    <option value="Big5">Big5</option>
                </select>
                <button onclick="clearRefMarkers()" class="danger" style="margin:0;">æ¸…é™¤</button>
            </div>
            <div id="ref-status" class="status-msg" style="color:var(--success);"></div>
        </div>
        
        <div class="section">
            <label>3. è·¯ç‡ˆè³‡æ–™åŒ¯å…¥ (OUTPUT.csv)</label>
            <span class="sub-text">* æ¬„ä½: name, x, y, G-code_1st</span>
            <input type="file" id="sl-csv-input" accept=".csv">
            
            <div class="filter-controls">
                <select id="sl-encoding">
                    <option value="UTF-8">UTF-8</option>
                    <option value="Big5">Big5</option>
                </select>
                <button onclick="clearStreetLights()" class="danger" style="margin:0;">æ¸…é™¤</button>
            </div>
            
            <label style="margin-top:12px; margin-bottom:4px;">ç¯©é¸èˆ‡æ“ä½œ:</label>
            <div class="filter-controls">
                <select id="sl-filter" onchange="updateFilter()">
                    <option value="all">ğŸ‘ï¸ é¡¯ç¤ºå…¨éƒ¨</option>
                    <option value="å™¨è®Š">ğŸ”§ å™¨è®Š</option>
                    <option value="å®¹è®Š">ğŸ’¡ å®¹è®Š (LED)</option>
                    <option value="å¢è¨­">â• å¢è¨­</option>
                    <option value="å¾…ç¢ºèª">â“ å¾…ç¢ºèª (ç„¡G-code)</option>
                </select>
                <button class="success" onclick="addManualStreetLight()" style="margin:0;">â• æ–°å¢</button>
            </div>
            <div id="sl-status" class="status-msg"></div>
            
            <button class="action" onclick="exportRegistrationSheet()">ğŸ“Š åŒ¯å‡ºç¯©é¸å¾Œç™»è¨˜å–®</button>
        </div>

        <div class="section">
            <label>4. æ‰‹å‹•ç¹ªåœ– (Draw)</label>
            <div class="draw-tools">
                <button onclick="setDrawMode('circle')" id="btn-draw-circle">â­• åœ“</button>
                <button onclick="setDrawMode('line')" id="btn-draw-line">â– ç·š</button>
                <button onclick="setDrawMode('text')" id="btn-draw-text">Aa å­—</button>
                <button onclick="setDrawMode(null)" id="btn-draw-cancel" style="background:#455a64; color:#fff;">âœ‹ åœæ­¢</button>
            </div>
            <div class="tool-options">
                <div style="display:flex; align-items:center; gap:5px; flex:1;">
                    <span style="color:var(--text-sub); font-size:11px;">é¡è‰²:</span>
                    <input type="color" id="input-color" value="#e74c3c" style="width:25px; height:25px; border:none; cursor:pointer; padding:0; background:none;">
                </div>
                <div style="display:flex; align-items:center; gap:5px; flex:1;">
                    <span style="color:var(--text-sub); font-size:11px;">å­—ç´š:</span>
                    <input type="number" id="input-font-size" value="16" min="8" max="72" style="width:40px; padding:2px; text-align:center;">
                </div>
            </div>
            <button onclick="clearDrawings()" class="outline" style="border-color:var(--danger); color:var(--danger);">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ‰‹ç¹ª</button>
        </div>

        <div class="section" style="border:none; box-shadow:none; padding:0; background:transparent;">
            <button class="primary" onclick="exportPDF()" style="padding:12px; font-size:14px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">ğŸ’¾ åŒ¯å‡ºåœ–å±¤ PDF (å«ç¯©é¸)</button>
            <div class="row">
                <button class="outline" onclick="saveProject()">ğŸ“‚ å„²å­˜å°ˆæ¡ˆ</button>
                <button class="outline" onclick="loadProjectClick()">ğŸ“‚ è¼‰å…¥å°ˆæ¡ˆ</button>
            </div>
            <input type="file" id="project-input" accept=".json" style="display: none;">
        </div>

        <div class="debug-footer">
            <button class="debug" onclick="downloadDebugLog()">ğŸ“¥ ä¸‹è¼‰é™¤éŒ¯ç´€éŒ„ (å ±éŒ¯æ™‚è«‹é»æˆ‘)</button>
        </div>
    </div>
</div>

<div id="map"></div>

<div id="edit-panel">
    <div class="panel-header" id="panel-header">
        <span>ğŸ› ï¸ å±¬æ€§ç·¨è¼¯</span>
        <button class="close-panel-btn" onclick="closeEditPanel()">Ã—</button>
    </div>
    <div class="panel-body">
        <div style="margin-bottom:10px; padding:5px; background:rgba(255,183,3,0.1); border:1px solid var(--accent-orange); border-radius:var(--radius); font-size:12px;">
            ç•¶å‰é¡åˆ¥: <b id="edit-type-display" style="color:var(--accent-orange)">--</b>
        </div>

        <label>G-code (åº§æ¨™):</label>
        <input type="text" id="edit-gcode" placeholder="ç•™ç©ºè¦–ç‚ºå¢è¨­..." onchange="updateEditProcessType()">
        
        <label>è®Šæ›´å‰å®¹é‡:</label>
        <input list="list-old-cap" id="edit-old" placeholder="ä¾‹å¦‚: 73W">
        
        <label>è®Šæ›´å¾Œå®¹é‡(VA):</label>
        <input list="list-new-cap" id="edit-new" placeholder="ä¾‹å¦‚: 73VA">

        <label>ç´…åœˆåŠå¾‘ (å…¬å°º):</label>
        <div class="radius-control">
            <input type="range" id="edit-radius-slider" min="1" max="20" step="0.5" value="7" style="flex:1;">
            <input type="number" id="edit-radius-input" value="7" min="1" max="20" step="0.5" style="width:50px; text-align:center;">
        </div>

        <div class="panel-buttons">
            <button id="btn-panel-save" class="primary" style="margin:0;">ç¢ºèªæ›´æ–°</button>
            <button id="btn-panel-reset" class="outline" style="margin:0;">æ¢å¾©ä½ç½®</button>
        </div>
    </div>
</div>

<canvas id="text-helper-canvas" style="display:none;"></canvas>

<datalist id="list-old-cap">
    <option value="73W">
    <option value="112W">
    <option value="220W">
    <option value="250W">
</datalist>
<datalist id="list-new-cap">
    <option value="73VA">
    <option value="88VA">
</datalist>

<script>
    // --- DEBUG LOGGER SYSTEM ---
    window.appLogs = [];
    function log(msg) { 
        const t = new Date().toISOString();
        const logMsg = `[${t}] INFO: ${msg}`;
        window.appLogs.push(logMsg);
        console.log(logMsg);
    }
    function err(msg, e) {
        const t = new Date().toISOString();
        const errMsg = `[${t}] ERROR: ${msg} \nSTACK: ${e ? e.stack : 'N/A'}`;
        window.appLogs.push(errMsg);
        console.error(msg, e);
    }
    window.downloadDebugLog = function() {
        if(window.appLogs.length === 0) { alert("ç›®å‰æ²’æœ‰ç´€éŒ„"); return; }
        const blob = new Blob([window.appLogs.join('\n')], { type: 'text/plain' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = "debug_log.txt";
        link.click();
    };
    window.onerror = function(message, source, lineno, colno, error) {
        err(`Global Error: ${message} at ${lineno}:${colno}`, error);
    };

    // --- Init ---
    log("App Initializing...");
    proj4.defs("EPSG:3828", "+proj=tmerc +lat_0=0 +lon_0=121 +x_0=250000 +y_0=0 +k=0.9999 +ellps=aust_SA +towgs84=-752,-358,-179,-.0000011698,.0000018398,.0000009822,.00002329 +units=m +no_defs");
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
    const taiGridMap = {'A': [170000, 2750000], 'B': [250000, 2750000], 'C': [330000, 2750000], 'D': [170000, 2700000], 'E': [250000, 2700000], 'F': [330000, 2700000], 'G': [170000, 2650000], 'H': [250000, 2650000], 'J': [90000, 2600000], 'K': [170000, 2600000], 'L': [250000, 2600000], 'M': [90000, 2550000], 'N': [170000, 2550000], 'O': [250000, 2550000], 'P': [90000, 2500000], 'Q': [170000, 2500000], 'R': [250000, 2500000], 'T': [170000, 2450000], 'U': [250000, 2450000], 'V': [170000, 2400000], 'W': [250000, 2400000], 'X': [275000, 2614000], 'Y': [275000, 2564000]};
    const EXACT_BOUNDS = { "G5050": [[24.183209, 120.613454], [24.176813, 120.623288]] };

    let map = L.map('map', { maxZoom: 25 }).setView([24.1800, 120.6200], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', maxZoom: 25, maxNativeZoom: 19 }).addTo(map);
    
    let pdfOverlay = null;
    let pdfDocBytes = null;
    let currentPdfName = "map"; 
    let boundsHandleNW, boundsHandleSE, boundsHandleCenter;
    let isLocked = false;
    let refMarkersLayer = L.layerGroup().addTo(map);
    let drawnItemsLayer = L.layerGroup().addTo(map);
    let streetLightsLayer = L.layerGroup().addTo(map);
    let streetLightsData = []; 
    let refDataMap = {}; 
    let refMarkersData = []; 
    let currentBaseBounds = null;
    let currentDrawMode = null;
    let tempDrawShape = null;

    let currentEditingSL = null; 
    const editPanel = document.getElementById('edit-panel');
    const panelHeader = document.getElementById('panel-header');

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // Explicitly define global functions to prevent ReferenceErrors from HTML buttons
    window.toggleSidebar = function() {
        document.getElementById('sidebar').classList.toggle('collapsed');
        setTimeout(() => { map.invalidateSize(); }, 300);
    };

    function getTimestampedName(baseName, ext) {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        const HH = String(now.getHours()).padStart(2, '0');
        const MM = String(now.getMinutes()).padStart(2, '0');
        const SS = String(now.getSeconds()).padStart(2, '0');
        return `${baseName}_${yyyy}${mm}${dd}_${HH}${MM}${SS}.${ext}`;
    }

    // --- PDF Logic ---
    document.getElementById('pdf-input').addEventListener('change', async function(e) {
        log("PDF input changed");
        const file = e.target.files[0];
        if (!file) return;
        currentPdfName = file.name.replace(/\.[^/.]+$/, "");
        const rawBuffer = await file.arrayBuffer();
        pdfDocBytes = rawBuffer.slice(0);
        const displayBuffer = rawBuffer.slice(0);
        
        const gridInfo = getGridBounds(file.name);
        const msgDiv = document.getElementById('auto-detect-msg');
        let initialBounds;

        if (gridInfo) {
            if(gridInfo.type === 'exact') {
                msgDiv.innerHTML = `âœ… ${file.name.substring(0,5)} (ç²¾æº–)`;
                initialBounds = gridInfo.bounds;
                currentBaseBounds = null;
            } else {
                msgDiv.innerHTML = `âœ… ${file.name.substring(0,5)} (è‡ªå‹•ç™½é‚Š)`;
                currentBaseBounds = gridInfo.bounds;
                initialBounds = gridInfo.bounds; // Removed scaling
            }
        } else {
            msgDiv.innerText = `âš ï¸ æœªåµæ¸¬åˆ°åœ–è™Ÿ`;
            currentBaseBounds = null;
        }

        const loadingTask = pdfjsLib.getDocument(displayBuffer);
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 4 }); 
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        const imgUrl = canvas.toDataURL('image/png');

        if (!initialBounds) {
            const c = map.getCenter();
            const latRad = c.lat * Math.PI / 180;
            const hDeg = 0.005; 
            const wDeg = hDeg * (viewport.width / viewport.height) / Math.cos(latRad); 
            initialBounds = [[c.lat + hDeg/2, c.lng - wDeg/2], [c.lat - hDeg/2, c.lng + wDeg/2]];
        }

        if (pdfOverlay) map.removeLayer(pdfOverlay);
        clearControlHandles();
        pdfOverlay = L.imageOverlay(imgUrl, initialBounds, { opacity: 0.6 }).addTo(map);
        createControlHandles(initialBounds);
        document.getElementById('btn-lock').disabled = false;
        map.fitBounds(initialBounds);
        log("PDF Loaded successfully");
    });

    function getGridBounds(filename) {
        const simpleName = filename.split('/').pop().split('.')[0].toUpperCase();
        if (EXACT_BOUNDS[simpleName]) return { type: 'exact', bounds: EXACT_BOUNDS[simpleName] };
        const match = simpleName.match(/([A-Z])(\d{2})(\d{2})/);
        if (!match) return null;
        const code = match[1], xIdx = parseInt(match[2]), yIdx = parseInt(match[3]);
        const base = taiGridMap[code];
        if (!base) return null;
        const startX = base[0] + (xIdx * 800), startY = base[1] + (yIdx * 500);
        const endX = startX + 800, endY = startY + 500;
        const p1 = proj4("EPSG:3828", "EPSG:4326", [startX, startY]);
        const p2 = proj4("EPSG:3828", "EPSG:4326", [endX, endY]);
        return { type: 'grid', bounds: [[p2[1], p1[0]], [p1[1], p2[0]]] };
    }

    // Removed applyScale and recalcBounds as requested

    function clearControlHandles() {
        if (boundsHandleNW) map.removeLayer(boundsHandleNW);
        if (boundsHandleSE) map.removeLayer(boundsHandleSE);
        if (boundsHandleCenter) map.removeLayer(boundsHandleCenter);
    }
    
    function createControlHandles(bounds) {
        if (!Array.isArray(bounds) && bounds.getNorthWest) {
            bounds = [bounds.getNorthWest(), bounds.getSouthEast()];
        }
        
        const icon = L.divIcon({ className: 'handle-icon', iconSize: [12, 12] });
        const centerIcon = L.divIcon({ className: 'move-handle-icon', html: '+', iconSize: [20, 20], iconAnchor: [10, 10] });
        boundsHandleNW = L.marker(bounds[0], { draggable: true, icon: icon }).addTo(map);
        boundsHandleSE = L.marker(bounds[1], { draggable: true, icon: icon }).addTo(map);
        const center = L.latLngBounds(bounds).getCenter();
        boundsHandleCenter = L.marker(center, { draggable: true, icon: centerIcon, zIndexOffset: 1000 }).addTo(map);

        const handleResize = (e) => {
            const isRatioLocked = document.getElementById('aspect-ratio-check').checked;
            const target = e.target;
            const isNW = (target === boundsHandleNW);
            let anchor = isNW ? boundsHandleSE.getLatLng() : boundsHandleNW.getLatLng();
            let current = target.getLatLng();
            if (isRatioLocked) {
                const oldB = pdfOverlay.getBounds();
                const oNW = oldB.getNorthWest(), oSE = oldB.getSouthEast();
                const ratio = (isNW ? (oNW.lng - oSE.lng) : (oSE.lng - oNW.lng)) / (isNW ? (oNW.lat - oSE.lat) : (oSE.lat - oNW.lat));
                current.lng = anchor.lng + (current.lat - anchor.lat) * ratio;
                target.setLatLng(current);
            }
            let newNW = isNW ? current : anchor, newSE = isNW ? anchor : current;
            pdfOverlay.setBounds([newNW, newSE]);
            boundsHandleCenter.setLatLng(L.latLngBounds([newNW, newSE]).getCenter());
        };
        const handleMove = (e) => {
            const newCenter = e.target.getLatLng();
            const oldCenter = pdfOverlay.getBounds().getCenter();
            const dLat = newCenter.lat - oldCenter.lat, dLng = newCenter.lng - oldCenter.lng;
            const b = pdfOverlay.getBounds();
            pdfOverlay.setBounds([[b.getNorth()+dLat, b.getWest()+dLng], [b.getSouth()+dLat, b.getEast()+dLng]]);
            boundsHandleNW.setLatLng([b.getNorth()+dLat, b.getWest()+dLng]);
            boundsHandleSE.setLatLng([b.getSouth()+dLat, b.getEast()+dLng]);
        };
        boundsHandleNW.on('drag', handleResize);
        boundsHandleSE.on('drag', handleResize);
        boundsHandleCenter.on('drag', handleMove);
    }
    
    window.toggleLock = function() {
        if (!pdfOverlay) return;
        isLocked = !isLocked;
        const btn = document.getElementById('btn-lock');
        if (isLocked) {
            clearControlHandles();
            pdfOverlay.getElement().style.pointerEvents = 'none';
            btn.innerText = 'ğŸ”’ ä½ç½®å·²é–å®š'; btn.className = 'success';
        } else {
            const b = pdfOverlay.getBounds();
            createControlHandles([b.getNorthWest(), b.getSouthEast()]);
            pdfOverlay.getElement().style.pointerEvents = 'auto';
            btn.innerText = 'ğŸ”“ è§£é–ä½ç½®'; btn.className = 'outline';
        }
    };
    
    document.getElementById('opacity-slider').addEventListener('input', e => { if(pdfOverlay) pdfOverlay.setOpacity(e.target.value); });
    
    window.showBoundsInfo = function() { if(pdfOverlay) alert(pdfOverlay.getBounds().toBBoxString()); };

    // --- Street Lights Logic ---
    document.getElementById('sl-csv-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const encoding = document.getElementById('sl-encoding').value;
        const inputElem = this;
        Papa.parse(file, {
            header: true, encoding: encoding, skipEmptyLines: true,
            complete: function(results) {
                let count = 0;
                results.data.forEach(row => {
                    const lat = parseFloat(row['y']), lng = parseFloat(row['x']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        createStreetLight({
                            name: row['name'],
                            g_code: row['G-code_1st'],
                            lat: lat,
                            lng: lng,
                            origLat: lat,
                            origLng: lng,
                            old_cap: "",
                            new_cap: "",
                            radius: 7 
                        });
                        count++;
                    }
                });
                document.getElementById('sl-status').innerText = `âœ… å·²è¼‰å…¥ ${count} ç­†è·¯ç‡ˆ`;
                inputElem.value = ''; 
                updateFilter();
            }
        });
    });

    function getProcessType(g_code) {
        if (!g_code || g_code.trim() === "") return "å¢è¨­";
        const gw = refDataMap[g_code];
        if (!gw) return "å¾…ç¢ºèª"; 
        if (gw.includes("éˆ‰å…‰ç‡ˆ")) return "å™¨è®Š";
        if (gw.includes("LED")) return "å®¹è®Š";
        return "å¾…ç¢ºèª"; 
    }

    function createStreetLight(data) {
        if(!data) { err("createStreetLight called with null data", new Error("Null Data")); return null; }
        if(!data.radius) data.radius = 7;
        if(!data.processType) data.processType = getProcessType(data.g_code);

        const marker = L.marker([data.lat, data.lng], {
            icon: L.divIcon({className:'drag-point-icon', iconSize:[12,12], bgPos:[0,0]}), 
            draggable: true
        }).addTo(streetLightsLayer);

        marker.bindTooltip(`<b>${data.name}</b><br>${data.g_code}<br><small>[${data.processType}]</small>`, { offset: [0, -5], direction: 'top' });

        const circle = L.circle([data.lat, data.lng], {radius: data.radius, color:'red', weight:2}).addTo(streetLightsLayer);

        const textLabel = L.marker([data.lat, data.lng], {
            icon: L.divIcon({ 
                className: 'text-label', 
                html: generateLabelHtml(data.name, data.new_cap), 
                iconSize: [150, 20], 
                iconAnchor: [-45, 10] 
            }),
            interactive: true, draggable: false 
        }).addTo(streetLightsLayer);

        const slObj = {
            id: Date.now() + Math.random(),
            data: data,
            layers: { marker, circle, textLabel }
        };
        streetLightsData.push(slObj);

        marker.on('drag', e => {
            circle.setLatLng(e.latlng);
            textLabel.setLatLng(e.latlng);
            slObj.data.lat = e.latlng.lat;
            slObj.data.lng = e.latlng.lng;
        });

        marker.on('click', (e) => {
            L.DomEvent.stopPropagation(e);
            openEditPanel(slObj);
        });

        return slObj;
    }

    // Explicitly Global Functions
    window.addManualStreetLight = function() {
        const name = prompt("è«‹è¼¸å…¥è·¯ç‡ˆåç¨±/ç·¨è™Ÿ:", "æ–°è·¯ç‡ˆ");
        if(name === null) return; 

        const center = map.getCenter();
        createStreetLight({
            name: name || "æ–°è·¯ç‡ˆ",
            g_code: "", 
            lat: center.lat,
            lng: center.lng,
            origLat: center.lat,
            origLng: center.lng,
            old_cap: "",
            new_cap: "",
            radius: 7
        });
        updateFilter(); 
    };

    window.updateFilter = function() {
        const filterVal = document.getElementById('sl-filter').value;
        streetLightsData.forEach(sl => {
            const isVisible = (filterVal === 'all') || (sl.data.processType === filterVal);
            if(isVisible) {
                if(!map.hasLayer(sl.layers.marker)) {
                    streetLightsLayer.addLayer(sl.layers.marker);
                    streetLightsLayer.addLayer(sl.layers.circle);
                    streetLightsLayer.addLayer(sl.layers.textLabel);
                }
            } else {
                streetLightsLayer.removeLayer(sl.layers.marker);
                streetLightsLayer.removeLayer(sl.layers.circle);
                streetLightsLayer.removeLayer(sl.layers.textLabel);
            }
        });
        const visibleCount = streetLightsData.filter(sl => (filterVal === 'all') || (sl.data.processType === filterVal)).length;
        document.getElementById('sl-status').innerText = `âœ… ç›®å‰é¡¯ç¤º: ${visibleCount} ç­† (${filterVal === 'all' ? 'å…¨éƒ¨' : filterVal})`;
    };

    function generateLabelHtml(name, cap) {
        const text = name + (cap ? `(${cap})` : "");
        return `<div style="color:red;font-size:14px;font-weight:bold;text-shadow:1px 1px 0 #fff;white-space:nowrap;">${text}</div>`;
    }

    function openEditPanel(slObj) {
        closeEditPanel();
        currentEditingSL = slObj;
        
        document.getElementById('edit-gcode').value = slObj.data.g_code || "";
        document.getElementById('edit-old').value = slObj.data.old_cap || "";
        document.getElementById('edit-new').value = slObj.data.new_cap || "";
        document.getElementById('edit-type-display').innerText = slObj.data.processType || "æœªçŸ¥";
        
        const r = slObj.data.radius || 7;
        document.getElementById('edit-radius-slider').value = r;
        document.getElementById('edit-radius-input').value = r;

        slObj.layers.textLabel.dragging.enable();
        slObj.layers.textLabel.getElement().style.cursor = 'move';
        slObj.layers.textLabel.getElement().style.border = '1px dashed red'; 

        editPanel.style.display = 'block';
    }

    window.closeEditPanel = function() {
        if (currentEditingSL) {
            currentEditingSL.layers.textLabel.dragging.disable();
            if(currentEditingSL.layers.textLabel.getElement()) {
                currentEditingSL.layers.textLabel.getElement().style.cursor = '';
                currentEditingSL.layers.textLabel.getElement().style.border = 'none';
            }
            currentEditingSL = null;
        }
        editPanel.style.display = 'none';
    };

    window.updateEditProcessType = function() {
        if(!currentEditingSL) return;
        const newCode = document.getElementById('edit-gcode').value;
        const newType = getProcessType(newCode);
        document.getElementById('edit-type-display').innerText = newType;
    }

    const rSlider = document.getElementById('edit-radius-slider');
    const rInput = document.getElementById('edit-radius-input');
    
    function updateRadius(val) {
        val = parseFloat(val);
        rSlider.value = val;
        rInput.value = val;
        if(currentEditingSL) {
            currentEditingSL.data.radius = val;
            currentEditingSL.layers.circle.setRadius(val);
        }
    }
    rSlider.oninput = function() { updateRadius(this.value); };
    rInput.onchange = function() { updateRadius(this.value); };

    document.getElementById('btn-panel-save').onclick = function() {
        if (!currentEditingSL) return;
        const slObj = currentEditingSL;
        
        slObj.data.g_code = document.getElementById('edit-gcode').value;
        slObj.data.old_cap = document.getElementById('edit-old').value;
        slObj.data.new_cap = document.getElementById('edit-new').value;
        
        slObj.data.processType = getProcessType(slObj.data.g_code);

        const newHtml = generateLabelHtml(slObj.data.name, slObj.data.new_cap);
        slObj.layers.textLabel.setIcon(L.divIcon({ 
            className: 'text-label', html: newHtml, iconSize: [150, 20], 
            iconAnchor: [-45, 10] 
        }));
        
        slObj.layers.marker.setTooltipContent(`<b>${slObj.data.name}</b><br>${slObj.data.g_code}<br><small>[${slObj.data.processType}]</small>`);
        
        closeEditPanel();
        updateFilter(); 
    };

    document.getElementById('btn-panel-reset').onclick = function() {
        if (!currentEditingSL) return;
        const slObj = currentEditingSL;
        const orig = L.latLng(slObj.data.origLat, slObj.data.origLng);
        
        slObj.layers.marker.setLatLng(orig);
        slObj.layers.circle.setLatLng(orig);
        slObj.layers.textLabel.setLatLng(orig);
        slObj.data.lat = orig.lat; slObj.data.lng = orig.lng;
        
        closeEditPanel();
    };

    let isPanelDragging = false;
    let panelOffsetX, panelOffsetY;
    panelHeader.addEventListener('mousedown', (e) => {
        isPanelDragging = true;
        panelOffsetX = e.clientX - editPanel.offsetLeft;
        panelOffsetY = e.clientY - editPanel.offsetTop;
        document.body.style.userSelect = 'none'; 
    });
    document.addEventListener('mousemove', (e) => {
        if (isPanelDragging) {
            editPanel.style.left = (e.clientX - panelOffsetX) + 'px';
            editPanel.style.top = (e.clientY - panelOffsetY) + 'px';
        }
    });
    document.addEventListener('mouseup', () => { isPanelDragging = false; document.body.style.userSelect = ''; });

    window.clearStreetLights = function(force = false) {
        if(force || confirm("æ¸…é™¤æ‰€æœ‰è·¯ç‡ˆè³‡æ–™?")) {
            streetLightsLayer.clearLayers();
            streetLightsData = [];
            document.getElementById('sl-status').innerText = "";
            document.getElementById('sl-csv-input').value = ""; 
            closeEditPanel();
        }
    };

    window.exportRegistrationSheet = function() {
        const filterVal = document.getElementById('sl-filter').value;
        const exportData = streetLightsData.filter(sl => (filterVal === 'all') || (sl.data.processType === filterVal));

        if(exportData.length === 0) return alert(`ç›®å‰ç¯©é¸ (${filterVal}) ç„¡è³‡æ–™å¯åŒ¯å‡º`);
        
        const csvRows = [];
        csvRows.push(["åºè™Ÿ","è®Šæ›´å‰é›»è™Ÿ","è®Šæ›´å¾Œé›»è™Ÿ","è¡Œæ”¿å€","è£è¨­ä½ç½®æˆ–åœ°å€","è£è¨­åœ°é»åº§æ¨™","è·¯ç‡ˆç·¨è™Ÿ(æ–°)","è®Šæ›´å‰ç‡ˆåˆ¥","è®Šæ›´å‰å°å¸³å®¹é‡","è®Šæ›´å‰å°å¸³ç›æ•¸","è®Šæ›´å¾Œç‡ˆåˆ¥","è®Šæ›´å¾Œå®¹é‡(VA)","è®Šæ›´å¾Œç›æ•¸","æœå‹™æ‰€","å—ç†è™Ÿç¢¼"]);
        
        exportData.forEach((item, index) => {
            const d = item.data;
            const matchedGW = refDataMap[d.g_code] || ""; 

            const row = [
                index + 1, 
                "", "", "", "", 
                d.g_code || "", 
                d.name || "",   
                matchedGW,          
                d.old_cap || "", 
                "1",            
                "LED",          
                d.new_cap || "", 
                "1",            
                "", ""      
            ];
            const safeRow = row.map(field => {
                const s = String(field);
                if (s.includes(",") || s.includes('"') || s.includes("\n")) {
                    return `"${s.replace(/"/g, '""')}"`;
                }
                return s;
            });
            csvRows.push(safeRow.join(","));
        });

        const csvContent = "\uFEFF" + csvRows.join("\n"); 
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const typeName = (filterVal === 'all') ? 'å…¨æ¡ˆ' : filterVal;
        const fname = getTimestampedName(`${currentPdfName}_${typeName}ç™»è¨˜å–®`, "csv");
        link.href = URL.createObjectURL(blob);
        link.download = fname;
        link.click();
    };

    window.setDrawMode = function(mode) {
        currentDrawMode = mode;
        map.dragging.enable();
        document.querySelectorAll('.draw-tools button').forEach(b => b.classList.remove('active'));
        if(mode) {
            document.getElementById('btn-draw-'+mode).classList.add('active');
            map.dragging.disable(); map.getContainer().style.cursor = 'crosshair';
        } else { map.getContainer().style.cursor = ''; }
    };
    
    window.clearDrawings = function(silent=false) { if(silent || confirm("ç¢ºå®šæ¸…é™¤?")) drawnItemsLayer.clearLayers(); };

    function createEditableCircle(latlng, radius, color) {
        const group = L.layerGroup().addTo(drawnItemsLayer);
        group.drawType = 'circle'; group.color = color;
        const circle = L.circle(latlng, {radius: radius, color: color, weight:2}).addTo(group);
        const handle = L.marker(latlng, {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        handle.on('drag', evt => { circle.setLatLng(evt.latlng); });
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn" style="background:#ef5350; color:white; border:none; padding:5px 10px; cursor:pointer; border-radius:4px;">åˆªé™¤æ­¤åœ“</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(group); };
        handle.bindPopup(popupContent);
        return { group, circle, handle };
    }
    function createEditableLine(latlngs, color) {
        const group = L.layerGroup().addTo(drawnItemsLayer);
        group.drawType = 'line'; group.color = color;
        const line = L.polyline(latlngs, {color: color, weight:3}).addTo(group);
        const h1 = L.marker(latlngs[0], {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        const h2 = L.marker(latlngs[1], {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        const updateLine = () => { line.setLatLngs([h1.getLatLng(), h2.getLatLng()]); };
        h1.on('drag', updateLine); h2.on('drag', updateLine);
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn" style="background:#ef5350; color:white; border:none; padding:5px 10px; cursor:pointer; border-radius:4px;">åˆªé™¤æ­¤ç·š</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(group); };
        line.bindPopup(popupContent);
        return { group, line };
    }
    function createEditableText(latlng, text, fontSize, color) {
        const marker = L.marker(latlng, {
            icon: L.divIcon({ className: 'text-label', html: `<div style="color:${color};font-size:${fontSize}px;font-weight:bold;text-shadow:1px 1px 0 #fff;white-space:nowrap;line-height:20px;">${text}</div>`, iconSize: [100, 20], iconAnchor: [0, 10] }),
            interactive: true, draggable: true
        }).addTo(drawnItemsLayer);
        marker.drawType = 'text'; marker.textContent = text; marker.fontSize = fontSize; marker.color = color;
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn" style="background:#ef5350; color:white; border:none; padding:5px 10px; cursor:pointer; border-radius:4px;">åˆªé™¤æ–‡å­—</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(marker); };
        marker.bindPopup(popupContent);
        return marker;
    }

    let startPoint = null;
    map.on('mousedown', function(e) {
        if(!currentDrawMode) return;
        startPoint = e.latlng;
        const color = document.getElementById('input-color').value;
        if(currentDrawMode === 'circle') tempDrawShape = L.circle(startPoint, {radius: 1, color:color, weight:2}).addTo(map);
        else if(currentDrawMode === 'line') tempDrawShape = L.polyline([startPoint, startPoint], {color:color, weight:3}).addTo(map);
        else if(currentDrawMode === 'text') {
            const text = prompt("è¼¸å…¥æ–‡å­—:", "è¨»è¨˜");
            if(text) { const fs = document.getElementById('input-font-size').value || 16; createEditableText(startPoint, text, fs, color); }
            setDrawMode(null);
        }
    });
    map.on('mousemove', function(e) {
        if(!currentDrawMode || !startPoint || !tempDrawShape) return;
        if(currentDrawMode === 'circle') tempDrawShape.setRadius(map.distance(startPoint, e.latlng));
        else if(currentDrawMode === 'line') tempDrawShape.setLatLngs([startPoint, e.latlng]);
    });
    map.on('mouseup', function(e) {
        if(!currentDrawMode || !startPoint) return;
        const color = document.getElementById('input-color').value;
        if(tempDrawShape) {
            if(currentDrawMode === 'circle') { const r = tempDrawShape.getRadius(); map.removeLayer(tempDrawShape); createEditableCircle(startPoint, r, color); }
            else if (currentDrawMode === 'line') { const lls = tempDrawShape.getLatLngs(); map.removeLayer(tempDrawShape); createEditableLine(lls, color); }
        }
        startPoint = null; tempDrawShape = null; setDrawMode(null);
    });

    document.getElementById('ref-csv-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const encoding = document.getElementById('csv-encoding').value;
        const inputElem = this;
        Papa.parse(file, {
            header: true, encoding: encoding, skipEmptyLines: true,
            complete: function(results) {
                let count = 0;
                refDataMap = {}; 
                refMarkersData = []; 
                results.data.forEach(row => {
                    const lat = parseFloat(row['G-y']), lng = parseFloat(row['G-x']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        if(row['G-code']) {
                            refDataMap[row['G-code']] = row['G-W'] || "";
                        }
                        const refItem = { lat, lng, code: row['G-code'], w: row['G-W'] };
                        refMarkersData.push(refItem);

                        const popupHtml = `
                            <div style="font-size:14px; display:flex; align-items:center; gap:8px;">
                                <b style="cursor:pointer; color:#2980b9; text-decoration:underline;" 
                                   title="é»æ“Šè¤‡è£½" 
                                   onclick="navigator.clipboard.writeText('${row['G-code']}').then(()=>alert('å·²è¤‡è£½: ${row['G-code']}'))">
                                   ${row['G-code']}
                                </b>
                                <span style="font-size:12px; color:#666;">(é»æ“Šè¤‡è£½)</span>
                            </div>
                            <div style="margin-top:4px;">${row['G-W']||''}</div>
                        `;
                        L.circleMarker([lat, lng], { color: 'green', fillColor: '#90EE90', fillOpacity: 0.8, radius: 5 })
                         .bindPopup(popupHtml).addTo(refMarkersLayer);
                        count++;
                    }
                });
                document.getElementById('ref-status').innerText = `âœ… å·²è¼‰å…¥ ${count} å€‹ (å«ç´¢å¼•)`;
                inputElem.value = ''; 
                
                streetLightsData.forEach(sl => {
                    if(!sl.data.processType || sl.data.processType === "å¾…ç¢ºèª") {
                        sl.data.processType = getProcessType(sl.data.g_code);
                        sl.layers.marker.setTooltipContent(`<b>${sl.data.name}</b><br>${sl.data.g_code}<br><small>[${sl.data.processType}]</small>`);
                    }
                });
                window.updateFilter();
            }
        });
    });
    window.clearRefMarkers = function() { refMarkersLayer.clearLayers(); refDataMap = {}; refMarkersData = []; };
    
    window.exportPDF = async function() {
        if (!pdfDocBytes || !pdfOverlay) return alert("è«‹å…ˆä¸Šå‚³ PDF");
        try {
            const { PDFDocument, rgb } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfDocBytes);
            const page = pdfDoc.getPages()[0];
            const { width: pdfW, height: pdfH } = page.getSize();
            const b = pdfOverlay.getBounds();
            const north = b.getNorth(), south = b.getSouth(), east = b.getEast(), west = b.getWest();

            function toPdfPoint(lat, lng) {
                return { x: ((lng - west)/(east - west))*pdfW, y: ((lat - south)/(north - south))*pdfH };
            }
            const hexToRgb = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                return rgb(r, g, b);
            }
            async function textToImageBytes(text, fontSize, color) {
                const c = document.getElementById('text-helper-canvas');
                const ctx = c.getContext('2d');
                const scale = 3; const fontStr = `bold ${fontSize * scale}px "Microsoft JhengHei", sans-serif`; 
                ctx.font = fontStr;
                const metrics = ctx.measureText(text);
                const w = Math.ceil(metrics.width); const h = Math.ceil(fontSize * scale * 1.5); 
                c.width = w; c.height = h;
                ctx.font = fontStr; ctx.fillStyle = color; ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, h/2);
                return new Promise(resolve => { c.toBlob(blob => { blob.arrayBuffer().then(resolve); }, 'image/png'); });
            }

            const currentFilter = document.getElementById('sl-filter').value;

            for (const sl of streetLightsData) {
                if(currentFilter !== 'all' && sl.data.processType !== currentFilter) continue;

                const lat = sl.layers.circle.getLatLng().lat;
                const lng = sl.layers.circle.getLatLng().lng;
                const pt = toPdfPoint(lat, lng);
                
                const r = sl.data.radius || 7;
                const edgePt = toPdfPoint(lat + r/111111, lng); 
                const pdfR = Math.abs(edgePt.y - pt.y);
                page.drawCircle({ x: pt.x, y: pt.y, size: pdfR, borderColor: rgb(1,0,0), borderWidth: 2 });

                const textLat = sl.layers.textLabel.getLatLng().lat;
                const textLng = sl.layers.textLabel.getLatLng().lng;
                const txtPt = toPdfPoint(textLat, textLng);
                
                const labelText = sl.data.name + (sl.data.new_cap ? `(${sl.data.new_cap})` : "");
                
                if(labelText.trim()) {
                    const pngBytes = await textToImageBytes(labelText, 14, '#ff0000');
                    const pngImage = await pdfDoc.embedPng(pngBytes);
                    const dims = pngImage.scale(0.25);
                    page.drawImage(pngImage, { 
                        x: txtPt.x + 18, 
                        y: txtPt.y - (dims.height/2), 
                        width: dims.width, 
                        height: dims.height 
                    });
                }
            }

            drawnItemsLayer.eachLayer(layer => {
                if (layer.drawType === 'circle') {
                    let circleLayer; layer.eachLayer(l => { if(l instanceof L.Circle) circleLayer = l; });
                    if(circleLayer) {
                        const pt = toPdfPoint(circleLayer.getLatLng().lat, circleLayer.getLatLng().lng);
                        const pdfR = Math.abs(toPdfPoint(circleLayer.getLatLng().lat + circleLayer.getRadius()/111111, circleLayer.getLatLng().lng).y - pt.y);
                        page.drawCircle({ x: pt.x, y: pt.y, size: pdfR, borderColor: hexToRgb(layer.color||'#ff0000'), borderWidth: 2 });
                    }
                } else if (layer.drawType === 'line') {
                    let lineLayer; layer.eachLayer(l => { if(l instanceof L.Polyline) lineLayer = l; });
                    if(lineLayer) {
                        const lls = lineLayer.getLatLngs();
                        const p1 = toPdfPoint(lls[0].lat, lls[0].lng), p2 = toPdfPoint(lls[1].lat, lls[1].lng);
                        page.drawLine({ start: { x: p1.x, y: p1.y }, end: { x: p2.x, y: p2.y }, thickness: 2, color: hexToRgb(layer.color||'#ff0000') });
                    }
                } else if (layer.drawType === 'text') {
                    const pt = toPdfPoint(layer.getLatLng().lat, layer.getLatLng().lng);
                    const fs = parseInt(layer.fontSize || 16);
                    if(layer.textContent) {
                        (async () => {
                            const pngBytes = await textToImageBytes(layer.textContent, fs, layer.color||'#ff0000');
                            const pngImage = await pdfDoc.embedPng(pngBytes);
                            const dims = pngImage.scale(0.25);
                            page.drawImage(pngImage, { x: pt.x, y: pt.y - (dims.height/2), width: dims.width, height: dims.height });
                        })();
                    }
                }
            });
            
            await new Promise(r => setTimeout(r, 800)); 

            const outBytes = await pdfDoc.save();
            const blob = new Blob([outBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            const fname = getTimestampedName(currentPdfName, "pdf");
            link.href = URL.createObjectURL(blob);
            link.download = fname;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        } catch (ex) { 
            err("Export Error: " + ex.message, ex);
            alert("åŒ¯å‡ºéŒ¯èª¤ï¼š" + ex.message); 
        }
    };

    window.saveProject = function() {
        if(!pdfOverlay) return;
        const b = pdfOverlay.getBounds();
        const drawings = [];
        drawnItemsLayer.eachLayer(layer => {
            if(layer.drawType === 'circle') {
                let c; layer.eachLayer(l => { if(l instanceof L.Circle) c = l; });
                if(c) drawings.push({ type: 'circle', lat: c.getLatLng().lat, lng: c.getLatLng().lng, radius: c.getRadius(), color: layer.color });
            } else if(layer.drawType === 'line') {
                let l; layer.eachLayer(line => { if(line instanceof L.Polyline) l = line; });
                if(l) drawings.push({ type: 'line', latlngs: l.getLatLngs(), color: layer.color });
            } else if(layer.drawType === 'text') {
                drawings.push({ type: 'text', lat: layer.getLatLng().lat, lng: layer.getLatLng().lng, content: layer.textContent, fontSize: layer.fontSize, color: layer.color });
            }
        });
        
        const sls = streetLightsData.map(sl => {
            return {
                data: sl.data, 
                lat: sl.layers.marker.getLatLng().lat,
                lng: sl.layers.marker.getLatLng().lng,
                textLat: sl.layers.textLabel.getLatLng().lat,
                textLng: sl.layers.textLabel.getLatLng().lng
            };
        });

        const data = {
            bounds: { north: b.getNorth(), south: b.getSouth(), east: b.getEast(), west: b.getWest() },
            // V23 Final: Remove legacy markers save
            drawings: drawings,
            streetLights: sls,
            refMarkers: refMarkersData
        };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const link = document.createElement('a');
        const fname = getTimestampedName(currentPdfName, "json");
        link.href = URL.createObjectURL(blob);
        link.download = fname;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    };

    window.loadProjectClick = function() { document.getElementById('project-input').click(); };
    
    document.getElementById('project-input').addEventListener('change', e => {
        log("Project file input changed");
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
            log("Project file loaded, parsing JSON...");
            try {
                const d = JSON.parse(evt.target.result);
                log("JSON Parsed Successfully.");
                
                // Clear existing
                clearStreetLights(true); 
                clearRefMarkers(); 
                clearDrawings(true); 
                drawnItemsLayer.clearLayers(); 

                // Restore Bounds
                // FIX V24: Enhanced Safety Check for Bounds
                if(d.bounds && pdfOverlay) {
                    if (typeof d.bounds.north !== 'number' || typeof d.bounds.south !== 'number' ||
                        typeof d.bounds.east !== 'number' || typeof d.bounds.west !== 'number') {
                        log("âš ï¸ Bounds data is corrupted (NaN or undefined). Skipping bounds restoration.");
                    } else {
                        log("Restoring Bounds...");
                        const b = [[d.bounds.north, d.bounds.west], [d.bounds.south, d.bounds.east]];
                        pdfOverlay.setBounds(b);
                        map.fitBounds(b);
                        if(!isLocked) { 
                            clearControlHandles(); 
                            // FIX V26: Convert Leaflet LatLngBounds object to Array
                            const bObj = pdfOverlay.getBounds();
                            createControlHandles([bObj.getNorthWest(), bObj.getSouthEast()]);
                        }
                    }
                }
                
                // Restore Ref Markers
                if(d.refMarkers && Array.isArray(d.refMarkers)) {
                    log(`Restoring ${d.refMarkers.length} RefMarkers...`);
                    refMarkersData = d.refMarkers;
                    let count = 0;
                    d.refMarkers.forEach((row, idx) => {
                        try {
                            if (!row || typeof row.lat !== 'number' || typeof row.lng !== 'number') {
                                log(`Skipping invalid RefMarker at index ${idx}`);
                                return;
                            }

                            const lat = row.lat, lng = row.lng;
                            if(row.code) refDataMap[row.code] = row.w || "";
                            
                            const popupHtml = `
                                <div style="font-size:14px; display:flex; align-items:center; gap:8px;">
                                    <b style="cursor:pointer; color:#2980b9; text-decoration:underline;" 
                                       title="é»æ“Šè¤‡è£½" 
                                       onclick="navigator.clipboard.writeText('${row.code}').then(()=>alert('å·²è¤‡è£½: ${row.code}'))">
                                       ${row.code}
                                    </b>
                                    <span style="font-size:12px; color:#666;">(é»æ“Šè¤‡è£½)</span>
                                </div>
                                <div style="margin-top:4px;">${row.w||''}</div>
                            `;
                            L.circleMarker([lat, lng], { color: 'green', fillColor: '#90EE90', fillOpacity: 0.8, radius: 5 })
                         .bindPopup(popupHtml).addTo(refMarkersLayer);
                            count++;
                        } catch(ex) { err(`Error restoring RefMarker ${idx}`, ex); }
                    });
                    document.getElementById('ref-status').innerText = `âœ… å·²é‚„åŸ ${count} å€‹ (å«ç´¢å¼•)`;
                } else {
                    refMarkersData = []; 
                }

                // Restore Drawings
                if(d.drawings && Array.isArray(d.drawings)) {
                    log(`Restoring ${d.drawings.length} Drawings...`);
                    d.drawings.forEach((item, idx) => {
                        try {
                            if (!item) return;

                            const color = item.color || '#ff0000';
                            if(item.type === 'circle') createEditableCircle([item.lat, item.lng], item.radius, color);
                            else if(item.type === 'line') createEditableLine(item.latlngs, color);
                            else if(item.type === 'text') createEditableText([item.lat, item.lng], item.content, item.fontSize, color);
                        } catch(ex) { err(`Error restoring Drawing ${idx}`, ex); }
                    });
                }

                // Restore Street Lights
                if(d.streetLights && Array.isArray(d.streetLights)) {
                    log(`Restoring ${d.streetLights.length} StreetLights...`);
                    d.streetLights.forEach((item, idx) => {
                        try {
                            // 1. Basic Check
                            if (!item) {
                                log(`StreetLight at index ${idx} is NULL or Undefined. Skipping.`);
                                return;
                            }
                            // 2. Data Check
                            if (!item.data) {
                                log(`StreetLight at index ${idx} missing 'data' property. Item: ${JSON.stringify(item)}`);
                                return;
                            }

                            // 3. Create
                            const slObj = createStreetLight(item.data); 
                            
                            // 4. Validate Creation
                            if (!slObj) {
                                log(`Failed to create StreetLight object at index ${idx}.`);
                                return;
                            }

                            // 5. Restore Position (Safe Access)
                            if (typeof item.lat === 'number' && typeof item.lng === 'number') {
                                const newPt = L.latLng(item.lat, item.lng);
                                slObj.layers.marker.setLatLng(newPt);
                                slObj.layers.circle.setLatLng(newPt);
                            } else {
                                log(`StreetLight index ${idx} has invalid lat/lng in root object: ${item.lat}, ${item.lng}`);
                            }
                            
                            if (typeof item.textLat === 'number' && typeof item.textLng === 'number') {
                                slObj.layers.textLabel.setLatLng([item.textLat, item.textLng]);
                            }

                            // 6. Update HTML Label
                            const newHtml = generateLabelHtml(item.data.name, item.data.new_cap);
                            slObj.layers.textLabel.setIcon(L.divIcon({ 
                                className: 'text-label', html: newHtml, iconSize: [150, 20], 
                                iconAnchor: [-45, 10] 
                            }));

                        } catch(ex) { err(`Critical Error restoring StreetLight ${idx}`, ex); }
                    });

                    document.getElementById('sl-status').innerText = `âœ… å·²é‚„åŸ ${d.streetLights.length} ç­†è·¯ç‡ˆ`;
                    try { window.updateFilter(); } catch(e) { err("Filter update failed", e); }
                }

                log("Project Loaded Complete.");

            } catch(ex) { 
                // FIX V24: Changed variable name from 'err' to 'ex' to avoid shadowing global function
                err("Fatal Load Error", ex);
                alert("è®€å–å¤±æ•—ï¼š\n" + ex.message + "\nè«‹é»æ“Šå´é‚Šæ¬„çš„ã€Œä¸‹è¼‰é™¤éŒ¯ç´€éŒ„ã€ä¸¦å›å ±çµ¦é–‹ç™¼è€…ã€‚"); 
            }
        };
        reader.readAsText(file);
    });
    
    log("Ready.");
</script>
</body>
</html>
